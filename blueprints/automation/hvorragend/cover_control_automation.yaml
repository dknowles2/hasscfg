blueprint:
  name: Cover Control Automation (CCA)
  description: "# ⭐ Cover Control Automation (CCA) ⭐\n### A comprehensive and highly
    configurable blueprint for roller shutters and roller blinds\n\n**Version**: 2024.05.03-01\n**Help**:
    [Community Thread](https://community.home-assistant.io/t/cover-control-automation-cca-a-comprehensive-and-highly-configurable-roller-blind-blueprint/680539)\n**Source
    Code**: [github.com/hvorragend](https://github.com/hvorragend/ha-blueprints/blob/main/blueprints/automation/cover_control_automation.yaml)\n**Tickets**:
    [Issues](https://github.com/hvorragend/ha-blueprints/issues)\n**Full Changelog**:
    [CHANGELOG.md](https://github.com/hvorragend/ha-blueprints/blob/main/blueprints/automation/CHANGELOG.md)\n\n<details>\n<summary><strong>Features</strong></summary>\n\n✅
    Automatic opening and closing the roller shutters\n✅ Freely configurable time
    windows for opening or closing\n✅ Brightness control and/or control via the sun-elevation\n✅
    The use of scheduler helpers are possible\n✅ Ventilation feature (Currently for
    two-way sensors)\n✅ Resident feature: keep the cover closed if resident is asleep\n✅
    Complete flexibility in almost all parameters (drive delays, waiting times, position
    tolerance)\n✅ Each feature can be activated or deactivated as required\n✅ Dynamic
    conditions possible (see examples in `Details`)\n✅ Extensive automatic sun shading
    with many different setting options (see features in `Details`)\n✅ Added the option
    to save the current status in a helper. This has the advantage that the cover
    can also be in other positions and the automation can still be executed. And manual
    interventions are not constantly overridden with every trigger.\n\n**Shading features**\n✅
    Sun azimuth\n✅ Sun elevation\n✅ Solar irradiation/Light intensity/Illuminance\n✅
    Weather Conditions\n✅ Two different temperature sensors (compare thresholds for
    indoor and/or outdoor sensors)\n✅ Not only the current temperature, but also the
    temperature forecast can also be taken into account.\n✅ If multiple criteria (e.g.
    temperature sensors and/or azimuth and/or elevation) are defined, shading will
    not occur until <ins>all</ins> criteria are met.\n\n</details>\n\n<details>\n<summary><strong>Condition
    examples</strong></summary>\n\n- If, for example, your blinds on the upper floor
    only close automatically and are not opened via the automation, you can also enable
    the blinds to be opened during this time by activating a vacation mode boolean.\n-
    If you have visitors or a party, you may not want the blinds to close. This can
    be easily configured using a party mode boolean.\n- If, for any reason, you want
    to pause the activation of shading or the ending of shading, this can be controlled
    via a shading boolean.\n- If you want to suspend the entire roller blind control
    for a short time, perhaps because maintenance work or window cleaning is being
    carried out, this is possible with just one boolean.\n- Are the roller blinds
    on side doors normally only opened by the automation system and never closed because
    you don't want to lock yourself out? But on vacation, the blinds should still
    be closed. This is how the conditions work.\n\n</details>\n\n<details>\n<summary><strong>Important
    notes</strong></summary>\n\n- It is <ins>not</ins> possible to execute this automation
    manually!\n- If you want to use sun elevation and/or azimuth it's strongly advised
    to use sun.sun. And please make sure your sun.sun entity is enabled!\n- `time_up_early`
    should be earlier `than time_up_late`\n- `time_up_early_non_workday` should be
    earlier than `time_up_late_non_workday`\n- `time_down_early` should be earlier
    than `time_down_late`\n- `time_down_early_non_workday` should be earlier than
    `time_down_late_non_workday`\n- `shading_azimuth_start` should be lower than `shading_azimuth_end`\n-
    `shading_elevation_min` should be lower than `shading_elevation_max`\n- `shading_sun_brightness_start`
    should be higher than `shading_sun_brightness_end`\n- `open_position` should be
    higher than `close_position`\n- `open_position` should be higher than `ventilate_position`\n-
    `close_position` should be lower than `ventilate_position`\n- `shading_position`
    should be higher than `close_position`\n- `shading_position` should be lower than
    `open_position`\n- `resident_sensor` is only allowed to be on/off/true/false\n-
    cover must have a `current_position` attribute\n- After <ins>manual creation</ins>
    of the helper in the GUI, it will be filled with standard content on the <ins>first
    trigger</ins>.\n  In rare cases, this may mean that the first trigger does not
    move the blinds. This may take care of itself with the next trigger later.\n  Alternatively,
    the roller blinds must be moved shortly once so that the automation system knows
    what the current status is.\n\n*This was originally a fork of Eimeel's blueprint
    [automatic_blinds_shading.yaml](https://gist.github.com/jmerifjKriwe/bffbc7424dd04f4a31d6a71f7012cd1f)
    and is largely based on his programming.*\nNote: My blueprint is not compatible
    with Eimeel's variant. I have used his basis, but the variables are completely
    different from his design.<br />\n\n</details>\n\n<details>\n<summary><strong>Latest
    changes</strong></summary>\n\n2024.03.21-01:\n  - **Breaking change** in the schedule
    helper usage! You can find the details in the section \"Selection of time control
    options\".\n  - New: Reduction of triggers and thus avoidance of overlaps due
    to running delays (fixes #40)\n  - New: Added possibility to disable the use of
    'set_cover_position' and 'set_cover_tilt_position' and only use the additional
    actions\n  - Fixed: Shading Forecast Weather Conditions\n  - Fixed: Ventilation
    mode should not only be ended in the evening, but whenever it is not yet daytime.\n
    \ - Fixed: Added the ventilation mode activation on closing down again\n  - Try
    to avoid overlaps in the execution of the automation if several triggers are triggered
    shortly after each other.\n  - Fixed: Optional weather conditions for \"shading
    in\" #41\n\n2024.04.05-01:\n  - Update: Forecast Temperature below 0 possible\n
    \ - Delay lines minimally changed\n  - Added: Allow shading to activate multiple
    times a day #44\n  - Fixed: Ventilation is usually activated too often.\n\n2024.04.08-01:\n
    \ - Fixed: Make the shading work even without a helper\n\n2024.05.01-01:\n  -
    Updated: Trigger shading at time_up_early and schedule helper state change, too\n
    \ - Fixed: Possibility to ignore actions after manual position changes\n  - Added
    Feature: Force activation of sun shading #49\n  - Fixed: Manual shutter movements
    after a core restart were not always recognised.\n\n2024.05.03-01:\n  - Minor
    editorial changes\n\n</details>\n"
  source_url: https://github.com/hvorragend/ha-blueprints/blob/main/blueprints/automation/cover_control_automation.yaml
  domain: automation
  homeassistant:
    min_version: 2023.9.0
  input:
    blind:
      name: "\U0001F3E0 Cover"
      description: 'Which blind or roller shutter should be automated?

        <details> <summary><code><strong>CLICK HERE:</strong> Information about a
        cover group</code></summary>


        In principle, you can use a group here. But please note that there are problems
        with position detection for a group of covers! For example, one cover may
        be at position 100% and the other cover at position 0%. This results in a
        wrong group-value of 50%.


        My clear recommendation is to create **one automation for each cover**.

        </details>'
      selector:
        entity:
          filter:
          - domain:
            - cover
          multiple: false
    auto_options:
      name: "\U0001F449 Automation options"
      description: 'This <ins>basically</ins> determines whether the cover is allowed
        to open or close.

        <details> <summary><code><strong>CLICK HERE:</strong> Further description</code></summary>


        This can be extended by further conditions (see below). However, it is important
        that the options are still activated here. Otherwise the conditions will not
        take effect.


        **Please ensure that the corresponding sensors are also specified.** For example,
        the brightness control only works if a brightness sensor is also specified.


        **Note:** If you want to use the <ins>lockout protection</ins>, I recommend
        configuring a cover status helper. Otherwise, the cover cannot be moved to
        the next state after the door contact is closed.

        </details>'
      default:
      - auto_up_enabled
      - auto_down_enabled
      - auto_brightness_enabled
      - auto_sun_enabled
      selector:
        select:
          options:
          - label: "1 - \U0001F53C - Enable automatic daily cover opening"
            value: auto_up_enabled
          - label: "2 - \U0001F53B - Enable automatic daily cover closing"
            value: auto_down_enabled
          - label: "3 - \U0001F505 - Enable control (for opening/closing) via brightness
              values"
            value: auto_brightness_enabled
          - label: 4 - ☀️ - Enable control (for opening/closing) via sun elevation
            value: auto_sun_enabled
          - label: "5 - \U0001F4A8 - Enable ventilation mode"
            value: auto_ventilate_enabled
          - label: "6 - \U0001F6AA - Enable lockout protection"
            value: auto_lockout_protection_enabled
          - label: "7 - \U0001F975 - Enable automatic shading / sun protection control"
            value: auto_shading_enabled
          multiple: true
          sort: false
          custom_value: false
          mode: list
    time_control:
      name: ⏲️ Selection of time control options
      description: "<details> <summary><code><strong>CLICK HERE:</strong> Further
        descriptions</code></summary>\n\nThe times for opening and closing the cover
        are usually configured here in the blueprint. There are various input fields
        here for this purpose. However, you can also activate a scheduler helper mode
        at this point. This would allow you to configure a different time period for
        keeping the cover open for each day. Unfortunately, the HA core currently
        only has a 30-minute time grid for the time configuration.\nWhen using scheduler
        helper - Important difference to the usual input fields!\n\n  - <ins>Without
        brightness or sun elevation control:</ins>\n    As soon as the helper state
        is switched on, the cover is opened.\n    The cover is closed when the helper
        state changes from off to on.\n\n  - <ins>With brightness or sun elevation
        control:</ins>\n    The cover is opened when the threshold is exceeded and
        the helper is on.\n    The cover is closed when the threshold is undershot
        and the helper is off.\n\n</details> <br /> <details> <summary><code><strong>CLICK
        HERE:</strong> Important information since version 2024.03.21-01</code></summary>\n\nIt
        is not possible to find out more about the status of the schedule helper in
        Home Assistant. I never know whether we are at the beginning or end of the
        period. However, this is important to avoid bouncing when controlling the
        brightness, for example. In order to recognise whether we are still in the
        opening period or the closing period, it is necessary to enter a very rough
        time period in the time variables in the blueprint. <br /> <ins>Example:</ins>
        If the schedule helper goes to the \"ON\" status at 08:00 and to the \"OFF\"
        status at 18:00, it is sufficient to configure the times as follows: <br /><br
        /> Time For Drive Up - Early: 06:00<br /> Time For Drive Up - Late: 12:00<br
        /><br /> Time For Drive Down - Early: 16:00<br /> Time For Drive Down - Late:
        22:00<br />\nThe times are not used for triggering, but only to divide the
        day into two halves!\n</details>"
      default: time_control_input
      selector:
        select:
          options:
          - label: ✏️ - Use the input fields here in the blueprint
            value: time_control_input
          - label: ⏲️ - Use an external schedule helper
            value: time_control_schedule
          sort: false
          multiple: false
          custom_value: false
    time_schedule_helper:
      name: ⏲️ Cover driving time schedule helper
      description: 'If enabled above, please select the schedule helper here. Of course,
        it is also important that the times in the helper are configured accordingly.
        Please create only one period in total. Example: Start at 08:00 and end at
        22:00. The helper can be created [here](https://my.home-assistant.io/redirect/helpers/).'
      default: []
      selector:
        entity:
          filter:
          - domain:
            - schedule
          multiple: false
    cover_status_options:
      name: "\U0001F9AE Status detection of the cover"
      description: '<details>

        <summary><code><strong>CLICK HERE:</strong> Further descriptions</code></summary>



        - <ins>Check the current position</ins>

        The automation only moves the cover if it is positioned at one of the defined
        positions (ventilate position, shading position, open position or closed position).
        Otherwise, the cover has been moved manually.

        After a manual movement, it is unclear what is intended to be achieved, so
        the automation no longer takes action.

        To automate the movement of the cover again, it must be moved to one of the
        defined positions beforehand.

        The advantage of this is that you don''t have to create a helper in Home Assistant.

        Only basic features are available with this setting.


        - <ins>Use an external cover status helper</ins>

        If you want to be able to intervene manually and the automation should execute
        the next movement as usual, a helper is required.

        *Without helper, the manual override would always be overwritten by the automation.*

        This has the advantage that the cover does not necessarily have to be in a
        defined position.

        With this selection, advanced features are possible and you can always rely
        on automation.


        </details>

        '
      default: cover_helper_disabled
      selector:
        select:
          options:
          - label: '#️⃣ Check the current position'
            value: cover_helper_disabled
          - label: "\U0001F9AE Use an external cover status helper"
            value: cover_helper_enabled
          sort: false
          multiple: false
          custom_value: false
    cover_status_helper:
      name: "\U0001F9AE Cover Status Helper"
      description: Helper used to store the last cover event. *Attention:* You will
        need to manually create a [input_text](https://my.home-assistant.io/redirect/helpers/)
        entity with a <ins>length of 254 chars</ins> for this. <br /><br />`Optional`
      default: []
      selector:
        entity:
          domain:
          - input_text
          multiple: false
    drive_time:
      name: "\U0001F9AE Cover Drive Time"
      description: Can be used to recognise manual control. Please round up a little
        and do not adjust too precisely. Is used to delay the trigger if too much
        or incorrect position data is sent back.
      default: 90
      selector:
        number:
          min: 0.0
          max: 180.0
          unit_of_measurement: seconds
          step: 1.0
          mode: slider
    auto_global_condition:
      name: ❓ Additional condition for the entire automation
      description: This condition allows you to control the execution of the <ins>entire</ins>
        automation dynamically and outside of the blueprint configuration. With this
        option you could enable a party mode. <br /><br />`Optional`
      default: []
      selector:
        condition: {}
    open_position:
      name: "\U0001F53C Open Position"
      description: What position should the cover be moved into when opening?
      default: 100
      selector:
        number:
          min: 0.0
          max: 100.0
          unit_of_measurement: '%'
          mode: slider
          step: 1.0
    open_tilt_position:
      name: "\U0001F53C Open Tilt Position"
      description: To which tilt position should the cover be moved when opening?
      default: 50
      selector:
        number:
          min: 0.0
          max: 100.0
          unit_of_measurement: '%'
          mode: slider
          step: 1.0
    time_up_early:
      name: "\U0001F53C Time For Drive Up - Early On Workdays"
      description: 'The earliest time at which the cover may be opened. The cover
        will be opened if <ins>AFTER</ins> this time the defined brightness or sun-elevation
        value is high enough. (**NOTE**: If a resident is defined, he must also be
        awake).'
      default: 06:00:00
      selector:
        time: {}
    time_up_early_non_workday:
      name: "\U0001F53C Time For Drive Up - Early On Non-Workdays"
      description: As directly above, but for non-workdays.
      default: 07:00:00
      selector:
        time: {}
    time_up_late:
      name: "\U0001F53C Time For Drive Up - Late On Workdays"
      description: 'The latest time at which the cover should be opened. If the required
        brightness or sun-elevation value has <ins>NOT</ins> yet been reached by this
        time, the cover will still be opened. (**NOTE**: If a resident is defined
        and he is still asleep, the cover will <ins>NOT</ins> be opened. It will only
        be opened when the resident has woken up).'
      default: 08:00:00
      selector:
        time: {}
    time_up_late_non_workday:
      name: "\U0001F53C Time For Drive Up - Late On Non-Workdays"
      description: As directly above, but for non-workdays.
      default: 08:00:00
      selector:
        time: {}
    auto_up_condition:
      name: "\U0001F53C Additional Condition For Opening The Cover"
      description: This condition can be used to dynamically control the <ins>opening</ins>
        of the cover. You can use this, for example, if the covers normally don't
        open, but you really want to do it on vacation. <br /><br />`Optional`
      default: []
      selector:
        condition: {}
    auto_up_force:
      name: "\U0001F53C Force Immediate Opening"
      description: "If the status of this entity changes to on or true, the cover
        is opened immediately and without further checking.\n<details> <summary><code><strong>CLICK
        HERE:</strong> Further description</code></summary>\n\nThis can be used for
        the following purposes under certain circumstances: Antifreeze, RainProtection
        or WindProtection.\nNote:\n  - To avoid further controls in these cases, the
        entity should perhaps also be taken into account in the additional conditions
        above.\n  - However, after forcing a state, you must ensure that you move
        to the correct target position yourself.\n\n</details> <br /><code>Optional</code>"
      default: []
      selector:
        entity:
          domain:
          - input_boolean
          - binary_sensor
          multiple: false
    auto_up_action:
      name: "\U0001F53C Additional Actions After Opening The Cover"
      description: Additional actions to run after opening the cover
      default: []
      selector:
        action: {}
    close_position:
      name: "\U0001F53B Close Position"
      description: What position should the cover be moved into when closing?
      default: 0
      selector:
        number:
          min: 0.0
          max: 100.0
          unit_of_measurement: '%'
          mode: slider
          step: 1.0
    close_tilt_position:
      name: "\U0001F53B Close Tilt Position"
      description: To which tilt position should the cover be moved when closing?
      default: 50
      selector:
        number:
          min: 0.0
          max: 100.0
          unit_of_measurement: '%'
          mode: slider
          step: 1.0
    time_down_early:
      name: "\U0001F53B Time For Drive Down - Early On Workdays"
      description: The earliest time at which the cover may be closed. The cover will
        be closed if <ins>AFTER</ins> this time the defined brightness or sun-elevation
        value is low enough.
      default: '16:00:00'
      selector:
        time: {}
    time_down_early_non_workday:
      name: "\U0001F53B Time For Drive Down - Early On Non-Workdays"
      description: As directly above, but for non-workdays.
      default: '16:00:00'
      selector:
        time: {}
    time_down_late:
      name: "\U0001F53B Time For Drive Down - Late On Workdays"
      description: The latest time at which the cover should be closed. If the required
        brightness or sun-elevation value has <ins>NOT</ins> yet been reached by this
        time, the cover will still be closed.
      default: '22:00:00'
      selector:
        time: {}
    time_down_late_non_workday:
      name: "\U0001F53B Time For Drive Down - Late On Non-Workdays"
      description: As directly above, but for non-workdays.
      default: '22:00:00'
      selector:
        time: {}
    auto_down_condition:
      name: "\U0001F53B Additional Condition For Closing The Cover"
      description: This condition can be used to dynamically control the <ins>closing</ins>
        of the cover. You can use this, for example, at Christmas time or if you want
        the covers to behave differently while on vacation. <br /><br />`Optional`
      default: []
      selector:
        condition: {}
    auto_down_force:
      name: "\U0001F53B Force Immediate Closing"
      description: "If the status of this entity changes to on or true, the cover
        is closed immediately and without further checking.\n<details> <summary><code><strong>CLICK
        HERE:</strong> Further description</code></summary>\n\nThis can be used for
        the following purposes under certain circumstances: Antifreeze, RainProtection
        or WindProtection.\nNote:\n  - To avoid further controls in these cases, the
        entity should perhaps also be taken into account in the additional conditions
        above.\n  - However, after forcing a state, you must ensure that you move
        to the correct target position yourself.\n\n</details> <br /><code>Optional</code>"
      default: []
      selector:
        entity:
          domain:
          - input_boolean
          - binary_sensor
          multiple: false
    auto_down_action:
      name: "\U0001F53B Additional Actions After Closing The Cover"
      description: Additional actions to run after closing the cover
      default: []
      selector:
        action: {}
    default_brightness_sensor:
      name: "\U0001F505 Default Brightness Sensor"
      description: This default brightness sensor can be defined here, which is used
        for daily up and down. <br /><br />`Optional`
      default: []
      selector:
        entity:
          filter:
          - domain:
            - sensor
          multiple: false
    brightness_time_duration:
      name: "\U0001F505 Brightness Time Duration"
      description: Defines the time to given brightness sensor must be stay above/below
        the thresholds.
      default: 30
      selector:
        number:
          min: 0.0
          max: 600.0
          mode: slider
          step: 1.0
          unit_of_measurement: seconds
    brightness_up:
      name: "\U0001F505 Brightness Value For Opening The Cover"
      description: At what brightness value should the cover be opened?
      default: 0
      selector:
        number:
          min: 0.0
          max: 1000.0
          unit_of_measurement: lx
          step: 10.0
          mode: slider
    brightness_down:
      name: "\U0001F505 Brightness Value For Closing The Cover"
      description: At what brightness value should the cover be closed? Must be lower
        then the brightness up value.
      default: 0
      selector:
        number:
          min: 0.0
          max: 1000.0
          unit_of_measurement: lx
          step: 10.0
          mode: slider
    default_sun_sensor:
      name: ☀️ Sun Sensor
      description: 'Which sensors provides attributes with current azimuth and elevation
        of sun. I strongly suggest to use sun.sun ([Sun integration](https://www.home-assistant.io/integrations/sun/)).
        Please make sure that the integration is activated and provides the attributes.
        <strong>Important: If you want to use automatic shading, the sensor must also
        be specified here. Regardless of whether the basic sun control is used.</strong>
        <br /><br />`Optional` <br /><br />`Shading`'
      default: sun.sun
      selector:
        entity:
          filter:
          - domain:
            - sun
          multiple: false
    sun_time_duration:
      name: ☀️ Sun Time Duration
      description: Defines the time to given sun sensor must be stay above/below the
        thresholds.
      default: 30
      selector:
        number:
          min: 0.0
          max: 600.0
          mode: slider
          step: 1.0
          unit_of_measurement: seconds
    sun_elevation_up:
      name: ☀️ Sun Elevation Value For Opening The Cover
      description: The cover will be <ins>opened</ins> if the sun elevation is over
        this value
      default: 0
      selector:
        number:
          min: -90.0
          max: 90.0
          unit_of_measurement: °
          step: 0.1
          mode: slider
    sun_elevation_down:
      name: ☀️ Sun Elevation Value For Closing The Cover
      description: The cover will be <ins>closed</ins> if the sun elevation is under
        this value
      default: 0
      selector:
        number:
          min: -90.0
          max: 90.0
          unit_of_measurement: °
          step: 0.1
          mode: slider
    drive_delay_fix:
      name: "\U0001F55B Fixed Drive Delay"
      description: Fixed drive delay to avoid radio interferences. <br /><br />`Optional`
      default: 0
      selector:
        number:
          min: 0.0
          max: 600.0
          unit_of_measurement: seconds
          step: 1.0
          mode: slider
    drive_delay_random:
      name: "\U0001F55B Random Drive Delay"
      description: Additional random delay.
      default: 5
      selector:
        number:
          min: 0.0
          max: 600.0
          unit_of_measurement: seconds
          step: 1.0
          mode: slider
    position_tolerance:
      name: 〰️ Position Tolerance
      description: 'Tolerance to be applied when comparing the current position with
        the to be position. These are absolute values. Not relative to the previous
        position values.

        <details> <summary><code><strong>CLICK HERE:</strong> Further descriptions</code></summary>


        Attention: Bear in mind that the other positions are not too close to each
        other if you include the tolerance. The following could cause problems and
        would then be <ins>incorrect</ins>: <br /> - Open Position = 100<br /> - Ventilate
        Position = 99<br /> - Tolerance >= 1<br />

        </details>'
      default: 0
      selector:
        number:
          min: 0.0
          max: 20.0
          unit_of_measurement: '%'
          mode: slider
          step: 1.0
    workday_sensor:
      name: "\U0001F4BC Sensor For Workday/Non-Workday"
      description: It may be desired to open a cover at a different time on work days
        than on non-work days. The corresponding binary sensor can be defined here.
        If not set, the cover will open every time at time_up_early. <br /><br />`Optional`
      default: []
      selector:
        entity:
          filter:
          - domain:
            - binary_sensor
          multiple: false
    resident_sensor:
      name: "\U0001F6CC Resident Mode"
      description: 'Overwrite mode for opening and unplannend closing. <details> <summary><code><strong>CLICK
        HERE:</strong> Further descriptions</code></summary>


        This switch can be used to override the automatic opening of the cover. If
        this sensor (input_boolean or binary_sensor) is set to ON, the cover will
        not open automatically.

        This can be used e.g. to define a resident for the room. In this case, the
        cover only opens when the resident is no longer asleep. <br /> For this it
        is necessary to use a boolean sensor that returns TRUE/ON for sleeping and
        FALSE/OFF for non-sleeping. <br /> The cover will also close (without checking
        the defined times) if this sensor switches to TRUE/ON (because the resident
        is sleeping).

        </details> <br /><code>Optional</code>'
      default: []
      selector:
        entity:
          domain:
          - input_boolean
          - binary_sensor
          multiple: false
    contact_sensor:
      name: "\U0001F4A8 Contact Sensor Entity"
      description: "The contact sensor is required for lockout protection and for
        ventilation mode. It must be a binary two-way contact sensor.\n<details> <summary><code><strong>CLICK
        HERE:</strong> Further descriptions</code></summary>\n\n\n  - <ins>Lockout
        protection:</ins> \U0001F6AA\n    <br />\n    The cover is not closed if the
        door contact is on or true.\n    <br /><br />\n  - <ins>Ventilation mode:</ins>
        \U0001F4A8\n    <br />\n    If the door contact changes to on/true, the cover
        is moved to the ventilation position.\n    The prerequisite is that the cover
        is already closed.\n    After the status changes to off/false, the close position
        is activated.\n    The same applies in the shading-out situation.\n\n</details>
        <br /><code>Optional</code>"
      default: []
      selector:
        entity:
          filter:
          - domain:
            - binary_sensor
            - input_boolean
          multiple: false
    ventilate_position:
      name: "\U0001F4A8 Ventilate Position"
      description: What position should the cover move to when opening the window/door
        and the cover is closed to allow ventilation? If closing is triggered and
        the contact_sensor is 'on' the cover will move to this position instead of
        closing completly <br /><br />Should not be 100. In this case please use 99.
        And please also note the information in the position tolerance. <br /><br
        />`Optional`
      default: 30
      selector:
        number:
          min: 0.0
          max: 100.0
          unit_of_measurement: '%'
          mode: slider
          step: 1.0
    ventilate_tilt_position:
      name: "\U0001F4A8 Ventilate Tilt Position"
      description: To which tilt position should the cover be moved for ventilation?
      default: 50
      selector:
        number:
          min: 0.0
          max: 100.0
          unit_of_measurement: '%'
          mode: slider
          step: 1.0
    auto_ventilate_condition:
      name: "\U0001F4A8 Additional Condition For Ventilation"
      description: This condition can be used to dynamically control the <ins>start
        of the ventilation</ins> of the cover. <br /><br />`Optional`
      default: []
      selector:
        condition: {}
    auto_ventilate_force:
      name: "\U0001F4A8 Force Immediate Ventilation"
      description: "If the status of this entity changes to on or true, the cover
        is immediately set to ventilation mode and without further checking.\n<details>
        <summary><code><strong>CLICK HERE:</strong> Further description</code></summary>\n\nThis
        can be used for the following purposes under certain circumstances: Antifreeze,
        RainProtection or WindProtection.\nNote:\n  - To avoid further controls in
        these cases, the entity should perhaps also be taken into account in the additional
        conditions above.\n  - However, after forcing a state, you must ensure that
        you move to the correct target position yourself.\n\n</details> <br /><code>Optional</code>"
      default: []
      selector:
        entity:
          domain:
          - input_boolean
          - binary_sensor
          multiple: false
    auto_ventilate_action:
      name: "\U0001F4A8 Additional Actions After Ventilating The Cover"
      description: Additional actions to run after ventilating the cover
      default: []
      selector:
        action: {}
    auto_ventilate_options:
      name: "\U0001F4A8 Ventilation Configuration"
      description: "Various different ventilation options.\n<details> <summary><code><strong>CLICK
        HERE:</strong> Further descriptions</code></summary>\n\n\n  - <ins>Enable
        delay in ventilation mode:</ins>\n    <br />\n    Normally, when the window
        contact is opened, there is no delay in the upcoming movements. If you do
        want this, you can activate it here.\n    <br /><br />\n    The \"Fixed Drive
        Delay\" and \"Random Drive Delay\" settings which are already used everywhere
        are then used.\n    <br /><br />\n  - <ins>Allow ventilation not only when
        closed:</ins>\n    <br />\n    Allow ventilation not only in closed state,
        but also when the position is below the ventilation position.\n\n</details>"
      default: []
      selector:
        select:
          options:
          - label: "\U0001F4A8 Enable delay in ventilation mode"
            value: ventilation_delay_enabled
          - label: "\U0001F4A8 Allow ventilation not only when closed"
            value: ventilation_if_lower_enabled
          multiple: true
          sort: false
          custom_value: false
          mode: list
    shading_position:
      name: "\U0001F975 Shading Position"
      description: To which position should the cover be moved for shading?<br /><br
        />`Shading`
      default: 25
      selector:
        number:
          min: 0.0
          max: 100.0
          unit_of_measurement: '%'
          mode: slider
          step: 1.0
    shading_tilt_position:
      name: "\U0001F975 Shading Tilt Position"
      description: To which tilt position should the cover be moved for shading? <br
        /><br />`Shading`
      default: 50
      selector:
        number:
          min: 0.0
          max: 100.0
          unit_of_measurement: '%'
          mode: slider
          step: 1.0
    shading_brightness_sensor:
      name: "\U0001F975 Brightness Sensor For Shading"
      description: An additional brightness sensor can be defined here, which is only
        used for shading. <br /><br />`Optional` <br /><br />`Shading`
      default: []
      selector:
        entity:
          filter:
          - domain:
            - sensor
          multiple: false
    shading_sun_brightness_start:
      name: "\U0001F975 Shading Brightness Start Value"
      description: The minimum brightness value from which shading should start. (Must
        be above the value of brightness end!) <br /><br />`Optional` <br /><br />`Shading`
      default: 35000
      selector:
        number:
          min: 0.0
          max: 100000.0
          unit_of_measurement: lx
          step: 10.0
          mode: slider
    shading_sun_brightness_end:
      name: "\U0001F975 Shading Brightness End Value"
      description: The brightness value from which shading is no longer necessary.
        (Must be below the value of brightness start!). <br /><br />`Optional` <br
        /><br />`Shading`
      default: 25000
      selector:
        number:
          min: 0.0
          max: 100000.0
          unit_of_measurement: lx
          step: 10.0
          mode: slider
    shading_azimuth_start:
      name: "\U0001F975 Shading Azimuth Start Value"
      description: What is the minimum azimuth at which the sun hits the window? (Shading
        will start) <br /><br />`The attribute of default sun sensor (configured above)
        is used.` <br /><br />`Shading`
      default: 95
      selector:
        number:
          min: 0.0
          max: 365.0
          unit_of_measurement: °
          mode: slider
          step: 1.0
    shading_azimuth_end:
      name: "\U0001F975 Shading Azimuth End Value"
      description: What is the maximum azimuth at which the sun hits the window? (Shading
        will stop) <br /><br />`The attribute of default sun sensor (configured above)
        is used.` <br /><br />`Shading`
      default: 265
      selector:
        number:
          min: 0.0
          max: 365.0
          unit_of_measurement: °
          mode: slider
          step: 1.0
    shading_elevation_min:
      name: "\U0001F975 Shading Elevation Minimum Value"
      description: Starting from which elevation of the sun should the window be shaded?
        (Here it makes sense to consider surrounding buildings, trees, etc.). <br
        /><br />`The attribute of default sun sensor (configured above) is used.`
        <br /><br />`Shading`
      default: 25
      selector:
        number:
          min: -90.0
          max: 90.0
          unit_of_measurement: °
          step: 0.1
          mode: slider
    shading_elevation_max:
      name: "\U0001F975 Shading Elevation Maximum Value"
      description: What is the maximal elevation for elevation? (In most cases, 90
        degrees is probably the most reasonable value. However, this can also be different
        due to surrounding buildings, etc.). <br /><br />`The attribute of default
        sun sensor (configured above) is used.` <br /><br />`Shading`
      default: 90
      selector:
        number:
          min: -90.0
          max: 90.0
          unit_of_measurement: °
          step: 0.1
          mode: slider
    shading_temperatur_sensor1:
      name: "\U0001F975 Shading Temperature Sensor 1"
      description: This is the main temperature sensor. (Here, for example, the current
        outdoor or indoor temperature can be used as a condition). This sensor does
        not have to be defined if the shading is to take place independently of it.
        <br /><br />`Optional` <br /><br />`Shading`
      selector:
        entity:
          filter:
          - domain:
            - sensor
          multiple: false
      default: []
    shading_min_temperatur1:
      name: "\U0001F975 Shading Temperature Sensor 1 Minimum Value"
      description: Minimum temperature for sensor 1 above which shading should occur.
        <br /><br />`Optional` <br /><br />`Shading`
      default: 18
      selector:
        number:
          min: 0.0
          max: 50.0
          step: 0.1
          mode: slider
          unit_of_measurement: °C
    shading_temperatur_sensor2:
      name: "\U0001F975 Shading Temperature Sensor 2"
      description: This is a secondary temperature sensor. (Here, for example, a temperature
        difference sensor can be used as a criterion. Or, if Shading Temperature Sensor
        1 is outdoor temperature, you can use indoor temperature). This sensor does
        not have to be defined. <br /><br />`Optional` <br /><br />`Shading`
      default: []
      selector:
        entity:
          filter:
          - domain:
            - sensor
          multiple: false
    shading_min_temperatur2:
      name: "\U0001F975 Shading Temperature Sensor 2 Minimum Value"
      description: Minimum temperature for sensor 2 above which shading should occur.
        <br /><br />`Optional` <br /><br />`Shading`
      default: 18
      selector:
        number:
          min: 0.0
          max: 50.0
          step: 0.1
          mode: slider
          unit_of_measurement: °C
    shading_forecast_sensor:
      name: "\U0001F975 Forecast Temperature Sensor"
      description: 'Another temperature sensor. In this case, however, explicitly
        for use with a forecast. The idea is that it can happen, especially in spring,
        that the value of the Forecast Temperatur Value exceeded by strong solar radiation
        and the shading would be started. However, in spring you may not want shading,
        but the solar radiation as a welcome, free heating is desired. So you can
        define via the forecast sensor that shading is only started at an expected
        daily maximum temperature. **NOTE**: Sensor must support weather.get_forecasts
        which has been introduced with HA 2023.9 <br /><br />`Optional` <br /><br
        />`Shading`'
      default: []
      selector:
        entity:
          filter:
          - domain:
            - weather
          multiple: false
    shading_forecast_temp:
      name: "\U0001F975 Forecast Temperatur Value"
      description: Minimum temperature for forecast sensor above which shading should
        occur. <br /><br />`Optional` <br /><br />`Shading`
      default: 20
      selector:
        number:
          min: 0.0
          max: 50.0
          step: 0.1
          mode: slider
          unit_of_measurement: °C
    shading_weather_conditions:
      name: "\U0001F975 Weather Conditions"
      description: 'Check the following weather conditions when activating the shading.
        **NOTE**: Forecast sensor needs to be defined <br /><br />`Optional` <br /><br
        />`Shading`'
      default:
      - sunny
      - partlycloudy
      - cloudy
      - clear
      selector:
        select:
          multiple: true
          options:
          - clear-night
          - clear
          - cloudy
          - fog
          - hail
          - lightning
          - lightning-rainy
          - partlycloudy
          - pouring
          - rainy
          - snowy
          - snowy-rainy
          - sunny
          - windy
          - windy-variant
          - exceptional
          sort: false
          custom_value: false
    shading_waitingtime_start:
      name: "\U0001F975 Waiting Time For Shading Start"
      description: To prevent excessive stress on the motor, a waiting time for starting
        shading can be defined here. Shading then only STARTs when the conditions
        are fulfilled over the entire waiting time IN. <br /><br />`Shading`
      default: 300
      selector:
        number:
          min: 0.0
          max: 3600.0
          unit_of_measurement: seconds
          mode: slider
          step: 1.0
    shading_waitingtime_end:
      name: "\U0001F975 Waiting Time For Shading End"
      description: To prevent excessive stress on the motor, a waiting time can be
        defined here. Shading then ENDs when ONE of the conditions is NOT fulfilled
        over the entire waiting time OUT. <br /><br />`Shading`
      default: 900
      selector:
        number:
          min: 0.0
          max: 3600.0
          unit_of_measurement: seconds
          mode: slider
          step: 1.0
    auto_shading_start_condition:
      name: "\U0001F975 Additional Condition For Activating Sun Shading"
      description: 'This condition can be used to dynamically control the <ins>shading-IN-automation</ins>
        of the cover. This can be useful if you want to temporarily disable automation
        (e.g. because of control by other automations). <br /> Another example: Here
        you could also set that the shading is only triggered in the summer season.
        <br /><br />`Optional` <br /><br />`Shading`'
      default: []
      selector:
        condition: {}
    auto_shading_end_condition:
      name: "\U0001F975 Additional Condition For Disabling Sun Shading"
      description: This condition can be used to dynamically control the <ins>shading-OUT-automation</ins>
        of the cover. This can be useful if you want to temporarily disable automation
        (e.g. because of control by other automations). <br /><br />`Optional` <br
        /><br />`Shading`
      default: []
      selector:
        condition: {}
    auto_shading_start_force:
      name: "\U0001F975 Force Activation Sun Shading"
      description: If the status of this entity changes to on or true, the shading
        is immediately activated and without further checking. <br /><br />`Optional`
      default: []
      selector:
        entity:
          domain:
          - input_boolean
          - binary_sensor
          multiple: false
    auto_shading_start_action:
      name: "\U0001F975 Additional Actions After Activating Sun Shading"
      description: Additional actions to run after activating sun shading
      default: []
      selector:
        action: {}
    auto_shading_end_action:
      name: "\U0001F975 Additional Actions After Disabling Sun Shading"
      description: Additional actions to run after disabling sun shading
      default: []
      selector:
        action: {}
    ignore_after_manual_config:
      name: ⚙️ Ignore after manual position changes
      description: Ignore the following actions after manual position changes. Cover
        Status Helper required!
      default: []
      selector:
        select:
          options:
          - label: "\U0001F53C - Ignore opening after manual position changes"
            value: ignore_opening_after_manual
          - label: "\U0001F53B - Ignore closing after manual position changes"
            value: ignore_closing_after_manual
          - label: "\U0001F4A8 - Ignore ventilation after manual position changes"
            value: ignore_ventilation_after_manual
          - label: "\U0001F975 - Ignore shading after manual position changes"
            value: ignore_shading_after_manual
          multiple: true
          sort: false
          custom_value: false
          mode: list
    individual_config:
      name: ⚙️ Individual Configuration
      description: "Various different options for some fine adjustments\n<details>
        <summary><code><strong>CLICK HERE:</strong> Further description</code></summary>\n\n
        \ - <ins>Prevent 'set_cover_position' and 'set_cover_tilt_position'</ins>\n
        \   There are devices that have problems when the two services 'set_cover_position'
        and 'set_cover_tilt_position' are executed directly one after the other.\n
        \   For example, there are Shelly devices that use the script [cover_position_tilt.yaml](https://gist.github.com/lukasvice/b364724d84c3ac4e160f7a7d8fa37066)
        here.\n    Or Homematic blind actuators, which can better use their own service
        for this: [homematicip_local.set_cover_combined_position](https://github.com/danielperna84/custom_homematic?tab=readme-ov-file#homematicip_localset_cover_combined_position).\n
        \   This option can be used to disable the standard services and allows the
        control to be implemented individually via the addtional actions.\n\n</details>"
      default: []
      selector:
        select:
          options:
          - label: "\U0001F6AB Prevent the cover from closing immediately after deactivating
              the lockout protection"
            value: prevent_close_after_lockout
          - label: "\U0001F6AB Prevent the cover from moving to a higher position
              when it is closed"
            value: prevent_higher_position_closing
          - label: "\U0001F6AB Prevent the automation from moving to a higher closing
              position at the end of shading"
            value: prevent_higher_position_shading_end
          - label: "\U0001F6AB Prevent the use of the 'get_forecasts' service"
            value: prevent_forecast_service
          - label: "\U0001F6AB Prevent the end of shading when the cover is already
              closed"
            value: prevent_shading_end_if_closed
          - label: "\U0001F6AB Prevent the use of 'set_cover_position' and 'set_cover_tilt_position'
              and only use the additional actions"
            value: prevent_default_cover_actions
          - label: "\U0001F7E9 Allow shading to activate multiple times a day"
            value: allow_shading_multiple_times
          multiple: true
          sort: false
          custom_value: false
          mode: list
    check_config:
      name: ✔️ Check Configuration
      description: With this boolean, you can enable or disable the basic plausibility
        check for the configuration. he check only takes place if the automation is
        executed manually.
      default: false
      selector:
        boolean: {}
    check_config_debuglevel:
      name: ✔️ Check Configuration - Debug level
      description: Choose the debug level for Syslog messages in case of configuration
        issues <br /> Please make sure that it suits your Home Assistant logger default
        level.
      default: info
      selector:
        select:
          multiple: false
          mode: dropdown
          options:
          - critical
          - debug
          - error
          - info
          - warning
          sort: false
          custom_value: false
trigger_variables:
  blind: !input blind
  open_position: !input open_position
  close_position: !input close_position
  shading_position: !input shading_position
  position_tolerance: !input position_tolerance
  auto_options: !input auto_options
  time_up_early: !input time_up_early
  time_up_early_non_workday: !input time_up_early_non_workday
  time_up_late: !input time_up_late
  time_up_late_non_workday: !input time_up_late_non_workday
  time_down_early: !input time_down_early
  time_down_early_non_workday: !input time_down_early_non_workday
  time_down_late: !input time_down_late
  time_down_late_non_workday: !input time_down_late_non_workday
  workday_sensor: !input workday_sensor
  default_brightness_sensor: !input default_brightness_sensor
  brightness_up: !input brightness_up
  brightness_down: !input brightness_down
  default_sun_sensor: !input default_sun_sensor
  sun_elevation_up: !input sun_elevation_up
  sun_elevation_down: !input sun_elevation_down
  contact_sensor: !input contact_sensor
  resident_sensor: !input resident_sensor
  time_control: !input time_control
  time_schedule_helper: !input time_schedule_helper
  shading_brightness_sensor: !input shading_brightness_sensor
  shading_temperatur_sensor1: !input shading_temperatur_sensor1
  shading_temperatur_sensor2: !input shading_temperatur_sensor2
  shading_min_temperatur1: !input shading_min_temperatur1
  shading_min_temperatur2: !input shading_min_temperatur2
  shading_azimuth_start: !input shading_azimuth_start
  shading_azimuth_end: !input shading_azimuth_end
  shading_elevation_min: !input shading_elevation_min
  shading_elevation_max: !input shading_elevation_max
  shading_sun_brightness_start: !input shading_sun_brightness_start
  shading_sun_brightness_end: !input shading_sun_brightness_end
  shading_forecast_temp: !input shading_forecast_temp
  is_shading_enabled: '{{ ''auto_shading_enabled'' in auto_options }}'
  is_up_enabled: '{{ ''auto_up_enabled'' in auto_options }}'
  is_down_enabled: '{{ ''auto_down_enabled'' in auto_options }}'
  is_brightness_enabled: '{{ ''auto_brightness_enabled'' in auto_options }}'
  is_sun_elevation_enabled: '{{ ''auto_sun_enabled'' in auto_options }}'
  is_ventilation_enabled: '{{ ''auto_ventilate_enabled'' in auto_options }}'
  is_lockout_protection_enabled: '{{ ''auto_lockout_protection_enabled'' in auto_options
    }}'
  is_time_field_enabled: '{{ ''time_control_input'' in time_control or time_control
    == [] or time_schedule_helper == [] }}'
  is_schedule_helper_enabled: '{{ ''time_control_schedule'' in time_control and time_schedule_helper
    != [] }}'
variables:
  version: 2024.05.03-01
  blind_entities: '{{ expand(blind) | map(attribute=''entity_id'') | list }}'
  current_position: '{{ state_attr(blind, ''current_position'') if state_attr(blind,
    ''current_position'') is not none else state_attr(blind, ''position'') }}'
  current_sun_azimuth: '{{ state_attr(default_sun_sensor, ''azimuth'') }}'
  current_sun_elevation: '{{ state_attr(default_sun_sensor, ''elevation'') }}'
  drive_delay_fix: !input drive_delay_fix
  drive_delay_random: !input drive_delay_random
  drive_time: !input drive_time
  time_up_early_today: "{% if time_up_early_non_workday == [] or workday_sensor ==
    [] or (is_state(workday_sensor, 'on')) %}\n  {{ time_up_early }}\n{% else %}\n
    \ {{ time_up_early_non_workday }}\n{% endif %}"
  time_up_late_today: "{% if time_up_late_non_workday == [] or workday_sensor == []
    or (is_state(workday_sensor, 'on')) %}\n  {{ time_up_late }}\n{% else %}\n  {{
    time_up_late_non_workday }}\n{% endif %}"
  time_down_early_today: "{% if time_down_early_non_workday == [] or workday_sensor
    == [] or (is_state(workday_sensor, 'on')) %}\n  {{ time_down_early }}\n{% else
    %}\n  {{ time_down_early_non_workday }}\n{% endif %}"
  time_down_late_today: "{% if time_down_late_non_workday == [] or workday_sensor
    == [] or (is_state(workday_sensor, 'on')) %}\n  {{ time_down_late }}\n{% else
    %}\n  {{ time_down_late_non_workday }}\n{% endif %}"
  open_tilt_position: !input shading_tilt_position
  close_tilt_position: !input close_tilt_position
  ventilate_position: !input ventilate_position
  ventilate_tilt_position: !input ventilate_tilt_position
  auto_up_force: !input auto_up_force
  auto_down_force: !input auto_down_force
  auto_ventilate_force: !input auto_ventilate_force
  auto_shading_start_force: !input auto_shading_start_force
  shading_tilt_position: !input shading_tilt_position
  shading_waitingtime_start: !input shading_waitingtime_start
  shading_waitingtime_end: !input shading_waitingtime_end
  shading_forecast_sensor: !input shading_forecast_sensor
  shading_weather_conditions: !input shading_weather_conditions
  check_config: !input check_config
  check_config_debuglevel: !input check_config_debuglevel
  cover_status_options: !input cover_status_options
  cover_status_helper: !input cover_status_helper
  is_status_helper_enabled: "{{\n  'cover_helper_enabled' in cover_status_options
    and\n  cover_status_helper != [] and\n  states(cover_status_helper) != [] and\n
    \ states(cover_status_helper) | regex_match(\"((\\[[^\\}]+)?\\{s*[^\\}\\{]{3,}?:.*\\}([^\\{]+\\])?)\")
    and\n  states(cover_status_helper) not in [\"unavailable\", \"none\", \"unknown\"]\n}}"
  is_cover_open: "{% if is_status_helper_enabled and states(cover_status_helper)|from_json|regex_search('open')
    and (states(cover_status_helper)|from_json).v >= 2 %}\n  {{ (states(cover_status_helper)|from_json).open.a
    | bool }}\n{% else %}\n  {{ false }}\n{% endif %}"
  is_cover_open_ts: "{% if is_status_helper_enabled and states(cover_status_helper)|from_json|regex_search('open')
    and (states(cover_status_helper)|from_json).v >= 2 %}\n  {{ (states(cover_status_helper)|from_json).open.t
    }}\n{% else %}\n  {{ 0 }}\n{% endif %}"
  is_cover_closed: "{% if is_status_helper_enabled and states(cover_status_helper)|from_json|regex_search('close')
    and (states(cover_status_helper)|from_json).v >= 2 %}\n  {{ (states(cover_status_helper)|from_json).close.a
    | bool }}\n{% else %}\n  {{ false }}\n{% endif %}"
  is_cover_closed_ts: "{% if is_status_helper_enabled and states(cover_status_helper)|from_json|regex_search('close')
    and (states(cover_status_helper)|from_json).v >= 2 %}\n  {{ (states(cover_status_helper)|from_json).close.t
    }}\n{% else %}\n  {{ 0 }}\n{% endif %}"
  is_cover_ventilated: "{% if is_status_helper_enabled and states(cover_status_helper)|from_json|regex_search('ventilate')
    and (states(cover_status_helper)|from_json).v >= 2 %}\n  {{ (states(cover_status_helper)|from_json).ventilate.a
    | bool }}\n{% else %}\n  {{ false }}\n{% endif %}"
  is_cover_ventilated_ts: "{% if is_status_helper_enabled and states(cover_status_helper)|from_json|regex_search('ventilate')
    and (states(cover_status_helper)|from_json).v >= 2 %}\n  {{ (states(cover_status_helper)|from_json).ventilate.t
    }}\n{% else %}\n  {{ 0 }}\n{% endif %}"
  is_cover_shaded: "{% if is_status_helper_enabled and states(cover_status_helper)|from_json|regex_search('shading')
    and (states(cover_status_helper)|from_json).v >= 2 %}\n  {{ (states(cover_status_helper)|from_json).shading.a
    | bool }}\n{% else %}\n  {{ false }}\n{% endif %}"
  is_cover_shaded_ts: "{% if is_status_helper_enabled and states(cover_status_helper)|from_json|regex_search('shading')
    and (states(cover_status_helper)|from_json).v >= 2 %}\n  {{ (states(cover_status_helper)|from_json).shading.t
    }}\n{% else %}\n  {{ 0 }}\n{% endif %}"
  is_cover_locked: "{% if is_status_helper_enabled and states(cover_status_helper)|from_json|regex_search('locked')
    and (states(cover_status_helper)|from_json).v >= 2 %}\n  {{ (states(cover_status_helper)|from_json).locked.a
    | bool }}\n{% else %}\n  {{ false }}\n{% endif %}"
  is_cover_locked_ts: "{% if is_status_helper_enabled and states(cover_status_helper)|from_json|regex_search('locked')
    and (states(cover_status_helper)|from_json).v >= 2 %}\n  {{ (states(cover_status_helper)|from_json).locked.t
    }}\n{% else %}\n  {{ 0 }}\n{% endif %}"
  is_cover_manual: "{% if is_status_helper_enabled and states(cover_status_helper)|from_json|regex_search('manual')
    and (states(cover_status_helper)|from_json).v >= 2 %}\n  {{ (states(cover_status_helper)|from_json).manual.a
    | bool }}\n{% else %}\n  {{ false }}\n{% endif %}"
  is_cover_manual_ts: "{% if is_status_helper_enabled and states(cover_status_helper)|from_json|regex_search('manual')
    and (states(cover_status_helper)|from_json).v >= 2 %}\n  {{ (states(cover_status_helper)|from_json).manual.t
    }}\n{% else %}\n  {{ 0 }}\n{% endif %}"
  cover_status_time: "{{\n  is_status_helper_enabled and\n  (states(cover_status_helper)|from_json).t\n}}"
  in_open_position: '{{ (current_position | int(default=101) <= open_position + position_tolerance)
    and (current_position | int(default=101) >= open_position - position_tolerance)
    }}'
  in_close_position: '{{ (current_position | int(default=101) <= close_position +
    position_tolerance) and (current_position | int(default=101) >= close_position
    - position_tolerance) }}'
  in_shading_position: '{{ (current_position | int(default=101) <= shading_position
    + position_tolerance) and (current_position | int(default=101) >= shading_position
    - position_tolerance) }}'
  in_ventilate_position: '{{ (current_position | int(default=101) <= ventilate_position
    + position_tolerance) and (current_position | int(default=101) >= ventilate_position
    - position_tolerance) }}'
  individual_config: !input individual_config
  prevent_close_after_lockout: '{{ ''_prevent_close_after_lockout'' in individual_config
    }}'
  prevent_higher_position_closing: '{{ ''prevent_higher_position_closing'' in individual_config
    }}'
  prevent_higher_position_shading_end: '{{ ''prevent_higher_position_shading_end''
    in individual_config }}'
  prevent_forecast_service: '{{ ''prevent_forecast_service'' in individual_config
    }}'
  prevent_shading_end_if_closed: '{{ ''prevent_shading_end_if_closed'' in individual_config
    }}'
  prevent_default_cover_actions: '{{ ''prevent_default_cover_actions'' in individual_config
    }}'
  allow_shading_multiple_times: '{{ ''allow_shading_multiple_times'' in individual_config
    }}'
  ignore_after_manual_config: !input ignore_after_manual_config
  ignore_opening_after_manual: '{{ ''ignore_opening_after_manual'' in ignore_after_manual_config
    }}'
  ignore_closing_after_manual: '{{ ''ignore_closing_after_manual'' in ignore_after_manual_config
    }}'
  ignore_ventilation_after_manual: '{{ ''ignore_ventilation_after_manual'' in ignore_after_manual_config
    }}'
  ignore_shading_after_manual: '{{ ''ignore_shading_after_manual'' in ignore_after_manual_config
    }}'
  auto_ventilate_options: !input auto_ventilate_options
  ventilation_delay_enabled: '{{ ''ventilation_delay_enabled'' in auto_ventilate_options
    }}'
  ventilation_if_lower_enabled: '{{ ''ventilation_if_lower_enabled'' in auto_ventilate_options
    }}'
mode: restart
max_exceeded: silent
trigger:
- platform: template
  value_template: "{% if time_up_early_non_workday == [] or workday_sensor == [] or
    (is_state(workday_sensor, 'on')) %}\n  {{ is_time_field_enabled and now() >= today_at(time_up_early)
    }}\n{% else %}\n  {{ is_time_field_enabled and now() >= today_at(time_up_early_non_workday)
    }}\n{% endif %}"
  id: t_bo_1
- platform: template
  value_template: "{% if time_up_late_non_workday == [] or workday_sensor == [] or
    (is_state(workday_sensor, 'on')) %}\n  {{ is_time_field_enabled and now() >= today_at(time_up_late)
    }}\n{% else %}\n  {{ is_time_field_enabled and now() >= today_at(time_up_late_non_workday)
    }}\n{% endif %}"
  id: t_bo_2
- platform: template
  value_template: '{{ is_schedule_helper_enabled and time_schedule_helper != [] and
    is_state(time_schedule_helper, [''true'', ''on'']) }}'
  id: t_bo_3
- platform: template
  value_template: "{{\n  is_brightness_enabled and\n  default_brightness_sensor !=
    [] and\n  (states(default_brightness_sensor) | float(default=brightness_up) >
    brightness_up)\n}}"
  for:
    seconds: !input brightness_time_duration
  id: t_bo_4
- platform: template
  value_template: "{{\n  is_sun_elevation_enabled and\n  default_sun_sensor != []
    and\n  (state_attr(default_sun_sensor, 'elevation') | float(default=sun_elevation_up)
    > sun_elevation_up)\n}}"
  for:
    seconds: !input sun_time_duration
  id: t_bo_5
- platform: state
  entity_id: !input resident_sensor
  from: 'on'
  to: 'off'
  id: t_bo_6
- platform: state
  entity_id: !input auto_up_force
  from: 'off'
  to: 'on'
  id: t_bo_force
- platform: template
  value_template: "{% if time_down_early_non_workday == [] or workday_sensor == []
    or (is_state(workday_sensor, 'on')) %}\n  {{ is_time_field_enabled and now() >=
    today_at(time_down_early) }}\n{% else %}\n  {{ is_time_field_enabled and now()
    >= today_at(time_down_early_non_workday) }}\n{% endif %}"
  id: t_bc_1
- platform: template
  value_template: "{% if time_down_late_non_workday == [] or workday_sensor == []
    or (is_state(workday_sensor, 'on')) %}\n  {{ is_time_field_enabled and now() >=
    today_at(time_down_late) }}\n{% else %}\n  {{ is_time_field_enabled and now()
    >= today_at(time_down_late_non_workday) }}\n{% endif %}"
  id: t_bc_2
- platform: template
  value_template: '{{ is_schedule_helper_enabled and time_schedule_helper != [] and
    is_state(time_schedule_helper, [''false'', ''off'']) }}'
  id: t_bc_3
- platform: template
  value_template: "{{\n  is_brightness_enabled and\n  default_brightness_sensor !=
    [] and\n  (states(default_brightness_sensor) | float(default=brightness_down)
    < brightness_down)\n}}"
  for:
    seconds: !input brightness_time_duration
  id: t_bc_4
- platform: template
  value_template: "{{\n  is_sun_elevation_enabled and\n  default_sun_sensor != []
    and\n  (state_attr(default_sun_sensor, 'elevation') | float(default=sun_elevation_down)
    < sun_elevation_down)\n}}"
  for:
    seconds: !input sun_time_duration
  id: t_bc_5
- platform: state
  entity_id: !input resident_sensor
  from: 'off'
  to: 'on'
  id: t_bc_6
- platform: state
  entity_id: !input auto_down_force
  from: 'off'
  to: 'on'
  id: t_bc_force
- platform: template
  value_template: '{{ is_ventilation_enabled and contact_sensor != [] and is_state(contact_sensor,
    [''true'', ''on'']) }}'
  id: t_co_open
- platform: template
  value_template: '{{ is_ventilation_enabled and contact_sensor != [] and is_state(contact_sensor,
    [''false'', ''off'']) }}'
  id: t_co_close
- platform: state
  entity_id: !input auto_ventilate_force
  from: 'off'
  to: 'on'
  id: t_co_force
- platform: template
  value_template: "{{\n  is_shading_enabled and\n  default_sun_sensor != [] and\n
    \ state_attr(default_sun_sensor, 'azimuth') | float(default=shading_azimuth_start)
    > shading_azimuth_start and\n  state_attr(default_sun_sensor, 'azimuth') | float(default=shading_azimuth_end)
    < shading_azimuth_end and\n  state_attr(default_sun_sensor, 'elevation') | float(default=shading_elevation_min)
    > shading_elevation_min and\n  (shading_brightness_sensor == [] or states(shading_brightness_sensor)
    | float(default=shading_sun_brightness_start) > shading_sun_brightness_start)
    and\n  (shading_temperatur_sensor1 == [] or states(shading_temperatur_sensor1)
    | float(default=shading_min_temperatur1) > shading_min_temperatur1) and\n  (shading_temperatur_sensor2
    == [] or states(shading_temperatur_sensor2) | float(default=shading_min_temperatur2)
    > shading_min_temperatur2)\n}}"
  for: 00:00:05
  id: t_si_1
- platform: state
  entity_id: !input auto_shading_start_force
  from: 'off'
  to: 'on'
  id: t_si_force
- platform: template
  value_template: "{{\n  is_shading_enabled and\n  shading_temperatur_sensor1 != []
    and\n  states(shading_temperatur_sensor1) | float(default=shading_min_temperatur1)
    < shading_min_temperatur1\n}}"
  for: 00:00:05
  id: t_so_1
- platform: template
  value_template: "{{\n  is_shading_enabled and\n  shading_temperatur_sensor2 != []
    and\n  states(shading_temperatur_sensor2) | float(default=shading_min_temperatur2)
    < shading_min_temperatur2\n}}"
  for: 00:00:05
  id: t_so_2
- platform: template
  value_template: "{{\n  is_shading_enabled and\n  shading_brightness_sensor != []
    and\n  states(shading_brightness_sensor) | float(default=shading_sun_brightness_end)
    < shading_sun_brightness_end\n}}"
  for: 00:00:05
  id: t_so_3
- platform: template
  value_template: "{{\n  is_shading_enabled and\n  default_sun_sensor != [] and\n
    \ (state_attr(default_sun_sensor, 'elevation') | float(default=shading_elevation_max)
    > shading_elevation_max)\n}}"
  for: 00:00:05
  id: t_so_4
- platform: template
  value_template: "{{\n  is_shading_enabled and\n  default_sun_sensor != [] and\n
    \ (state_attr(default_sun_sensor, 'azimuth') | float(default=shading_azimuth_end)
    > shading_azimuth_end)\n}}"
  for: 00:00:05
  id: t_so_5
- platform: template
  value_template: "{{\n  is_shading_enabled and\n  default_sun_sensor != [] and\n
    \ (state_attr(default_sun_sensor, 'elevation') | float(default=shading_elevation_min)
    < shading_elevation_min)\n}}"
  for: 00:00:05
  id: t_so_6
- platform: state
  entity_id: !input blind
  attribute: current_position
  id: t_ma_1
  for: 00:01:00
condition:
- condition: !input auto_global_condition
- condition: template
  value_template: '{{ state_attr(this.entity_id,''current'') | int(99) == 0 }}'
- condition: template
  value_template: '{{ trigger.to_state.state not in [''unavailable'', ''unknown'',''none'',
    ''query failed''] }}'
action:
- if:
  - '{{ is_shading_enabled }}'
  - '{{ not prevent_forecast_service }}'
  - '{{ (shading_forecast_sensor != [] ) }}'
  - condition: trigger
    id: t_si_1
  then:
  - service: weather.get_forecasts
    target:
      entity_id: !input shading_forecast_sensor
    data:
      type: daily
    response_variable: weather_forecast
- if:
  - '{{ ''cover_helper_enabled'' in cover_status_options }}'
  - '{{ cover_status_helper != [] }}'
  - or:
    - '{{ not states(cover_status_helper) | regex_match("((\[[^\}]+)?\{s*[^\}\{]{3,}?:.*\}([^\{]+\])?)")
      }}'
    - '{{ states(cover_status_helper) in ["unavailable", "none", "unknown"] }}'
  then:
  - service: input_text.set_value
    data:
      entity_id: !input cover_status_helper
      value: "{% set dict_var = {\n  'open':{'a':false,'t':0},\n  'close':{'a':false,'t':0},\n
        \ 'ventilate':{'a':false,'t':0},\n  'shading':{'a':false,'t':0},\n  'locked':{'a':false,'t':0},\n
        \ 'manual':{'a':false,'t':0},\n  'p':current_position,\n  'v':4,\n  't':as_timestamp(now())
        | round(0)\n  }\n%}\n{{ dict_var | to_json }}\n"
- if:
  - '{{ is_status_helper_enabled }}'
  - '{{ (states(cover_status_helper)|from_json).v != 4 }}'
  then:
  - service: input_text.set_value
    data:
      entity_id: !input cover_status_helper
      value: "{% set dict_var = {\n  'open':{'a':is_cover_open,'t':is_cover_open_ts},\n
        \ 'close':{'a':is_cover_closed,'t':is_cover_closed_ts},\n  'ventilate':{'a':is_cover_ventilated,'t':is_cover_ventilated_ts},\n
        \ 'shading':{'a':is_cover_shaded,'t':is_cover_shaded_ts},\n  'locked':{'a':is_cover_locked,'t':is_cover_locked_ts},\n
        \ 'manual':{'a':is_cover_manual,'t':is_cover_manual_ts},\n  'p':current_position,\n
        \ 'v':4,\n  't':cover_status_time | round(0)\n  }\n%}\n{{ dict_var | to_json
        }}\n"
- choose:
  - alias: Check for opening
    conditions:
    - '{{ is_up_enabled }}'
    - condition: !input auto_up_condition
    - condition: trigger
      id:
      - t_bo_1
      - t_bo_2
      - t_bo_3
      - t_bo_4
      - t_bo_5
      - t_bo_6
    - '{{ auto_down_force == [] or auto_down_force != [] and is_state(auto_down_force,
      [''false'', ''off'']) }}'
    - or:
      - '{{ is_status_helper_enabled and not is_cover_open }}'
      - '{{ is_ventilation_enabled and in_ventilate_position }}'
      - '{{ in_close_position }}'
    - or:
      - '{{ not is_status_helper_enabled }}'
      - '{{ is_status_helper_enabled and not is_cover_manual }}'
      - '{{ is_status_helper_enabled and ignore_opening_after_manual }}'
      - '{{ is_status_helper_enabled and is_cover_manual and not ignore_opening_after_manual
        }}'
    - or:
      - '{{ not is_status_helper_enabled }}'
      - '{{ is_status_helper_enabled and (now().day != is_cover_open_ts|timestamp_custom(''%-d'')|int)
        }}'
    - or:
      - '{{ resident_sensor == [] }}'
      - '{{ is_state(resident_sensor, [''false'', ''off'']) }}'
    - or:
      - and:
        - '{{ is_time_field_enabled }}'
        - '{{ now() >= today_at(time_up_late_today) }}'
        - '{{ now() <= today_at(time_down_early_today) - timedelta(seconds = 5) }}'
      - and:
        - '{{ is_schedule_helper_enabled }}'
        - '{{ time_schedule_helper != [] }}'
        - '{{ is_state(time_schedule_helper, ''on'') }}'
        - condition: trigger
          id: t_bo_3
      - and:
        - or:
          - and:
            - '{{ is_time_field_enabled }}'
            - '{{ now() >= today_at(time_up_early_today) }}'
            - '{{ now() <= today_at(time_up_late_today) + timedelta(seconds = 5) }}'
          - and:
            - '{{ is_schedule_helper_enabled }}'
            - '{{ time_schedule_helper != [] }}'
            - '{{ is_state(time_schedule_helper, ''on'') }}'
            - '{{ now() >= today_at([time_up_early, time_up_early_non_workday] | min)
              - timedelta(seconds = 5) }}'
            - '{{ now() <= today_at([time_up_late, time_up_late_non_workday] | max)
              + timedelta(seconds = 5) }}'
        - or:
          - or:
            - '{{ is_brightness_enabled and default_brightness_sensor == [] }}'
            - '{{ is_brightness_enabled and default_brightness_sensor != [] and (states(default_brightness_sensor)
              | float(default=brightness_up) > brightness_up) }}'
          - or:
            - '{{ is_sun_elevation_enabled and default_sun_sensor == [] }}'
            - '{{ is_sun_elevation_enabled and default_sun_sensor != [] and (current_sun_elevation
              | float(default=sun_elevation_up) > sun_elevation_up) }}'
    sequence:
    - delay:
        seconds: '{{ range(drive_delay_fix|int(0), drive_delay_fix|int(0) + drive_delay_random|int(0)
          +1) | random }}'
    - if:
      - '{{ not prevent_default_cover_actions}}'
      then:
      - repeat:
          for_each: '{{ blind_entities|list }}'
          sequence:
          - if:
            - '{{ open_position == 100 }}'
            then:
            - alias: Moving the cover to open position
              service: cover.open_cover
              data: {}
              target:
                entity_id: '{{ repeat.item }}'
            else:
            - alias: Moving the cover to open position
              service: cover.set_cover_position
              data:
                position: !input open_position
              target:
                entity_id: '{{ repeat.item }}'
          - if:
            - '{{ state_attr(repeat.item, ''current_tilt_position'') != none }}'
            then:
            - alias: Moving the cover to tilt position
              service: cover.set_cover_tilt_position
              data:
                tilt_position: !input open_tilt_position
              target:
                entity_id: '{{ repeat.item }}'
          - alias: Wait 1-5 random seconds to prevent sending to many commands to
              covers at same time
            delay:
              seconds: '{{ (range(1, 3)|random|int) }}'
    - if:
      - '{{ ''cover_helper_enabled'' in cover_status_options }}'
      then:
      - service: input_text.set_value
        data:
          entity_id: !input cover_status_helper
          value: "{% set dict_var = states(cover_status_helper) | from_json %}\n{%
            set dict_new = dict(dict_var, **{\n  'open':{'a':true,'t':as_timestamp(now())
            | round(0)},\n  'close':{'a':false,'t':dict_var.close.t},\n  'ventilate':{'a':false,'t':dict_var.ventilate.t},\n
            \ 'shading':{'a':false,'t':dict_var.shading.t},\n  'locked':{'a':false,'t':dict_var.locked.t},\n
            \ 'manual':{'a':false,'t':dict_var.manual.t},\n  'p':current_position,\n
            \ 'v':4,\n  't':as_timestamp(now()) | round(0)\n  })\n%}\n{{ dict_new
            | to_json }}\n"
    - choose: []
      default: !input auto_up_action
    - stop: 'Stop automation: Opening'
  - alias: Check for closing cover
    conditions:
    - '{{ is_down_enabled }}'
    - condition: !input auto_down_condition
    - condition: trigger
      id:
      - t_bc_1
      - t_bc_2
      - t_bc_3
      - t_bc_4
      - t_bc_5
      - t_bc_6
    - '{{ auto_up_force == [] or auto_up_force != [] and is_state(auto_up_force, [''false'',
      ''off'']) }}'
    - '{{ auto_ventilate_force == [] or auto_ventilate_force != [] and is_state(auto_ventilate_force,
      [''false'', ''off'']) }}'
    - or:
      - '{{ not prevent_higher_position_shading_end }}'
      - '{{ not is_cover_shaded }}'
      - '{{ not in_shading_position }}'
      - and:
        - '{{ is_status_helper_enabled }}'
        - '{{ prevent_higher_position_shading_end }}'
        - '{{ is_cover_shaded }}'
        - '{{ close_position < shading_position }}'
      - and:
        - '{{ prevent_higher_position_shading_end }}'
        - '{{ in_shading_position }}'
        - '{{ close_position < shading_position }}'
    - or:
      - '{{ not prevent_higher_position_closing }}'
      - '{{ prevent_higher_position_closing and (current_position | int(default=101)
        >= close_position) }}'
    - or:
      - '{{ is_status_helper_enabled and not is_cover_closed }}'
      - '{{ in_open_position }}'
    - or:
      - '{{ not is_status_helper_enabled }}'
      - '{{ is_status_helper_enabled and not is_cover_manual }}'
      - '{{ is_status_helper_enabled and ignore_closing_after_manual }}'
      - '{{ is_status_helper_enabled and is_cover_manual and not ignore_closing_after_manual
        }}'
    - or:
      - '{{ not is_status_helper_enabled }}'
      - '{{ is_status_helper_enabled and (is_cover_closed_ts < today_at(time_down_early)
        | as_timestamp) }}'
    - or:
      - and:
        - '{{ is_time_field_enabled }}'
        - '{{ now() >= today_at(time_down_late_today) }}'
      - and:
        - '{{ is_schedule_helper_enabled }}'
        - '{{ time_schedule_helper != [] }}'
        - '{{ is_state(time_schedule_helper, ''off'') }}'
        - condition: trigger
          id: t_bc_3
      - and:
        - or:
          - and:
            - '{{ is_time_field_enabled }}'
            - '{{ now() >= today_at(time_down_early_today) }}'
            - '{{ now() <= today_at(time_down_late_today) + timedelta(seconds = 5)
              }}'
          - and:
            - '{{ is_schedule_helper_enabled }}'
            - '{{ time_schedule_helper != [] }}'
            - '{{ is_state(time_schedule_helper, ''on'') }}'
            - '{{ now() >= today_at([time_down_early, time_down_early_non_workday]
              | min) - timedelta(seconds = 5) }}'
            - '{{ now() <= today_at([time_down_late, time_down_late_non_workday] |
              max) + timedelta(seconds = 5) }}'
        - or:
          - or:
            - '{{ is_brightness_enabled and default_brightness_sensor == [] }}'
            - '{{ is_brightness_enabled and default_brightness_sensor != [] and (states(default_brightness_sensor)
              | float(default=brightness_down) < brightness_down) }}'
          - or:
            - '{{ is_sun_elevation_enabled and default_sun_sensor == [] }}'
            - '{{ is_sun_elevation_enabled and default_sun_sensor != [] and (current_sun_elevation
              | float(default=sun_elevation_down) < sun_elevation_down) }}'
      - and:
        - condition: trigger
          id: t_bc_6
        - '{{ resident_sensor != [] }}'
        - '{{ is_state(resident_sensor, [''true'', ''on'']) }}'
    sequence:
    - if:
      - '{{ is_lockout_protection_enabled }}'
      - '{{ contact_sensor != [] }}'
      - '{{ is_state(contact_sensor, [''true'', ''on'']) }}'
      then:
      - if:
        - '{{ ''cover_helper_enabled'' in cover_status_options }}'
        then:
        - service: input_text.set_value
          data:
            entity_id: !input cover_status_helper
            value: "{% set dict_var = states(cover_status_helper) | from_json %}\n{%
              set dict_new = dict(dict_var, **{\n  'open':{'a':false,'t':dict_var.open.t},\n
              \ 'close':{'a':false,'t':dict_var.close.t},\n  'ventilate':{'a':false,'t':dict_var.ventilate.t},\n
              \ 'shading':{'a':false,'t':dict_var.shading.t},\n  'locked':{'a':true,'t':as_timestamp(now())
              | round(0)},\n  'manual':{'a':false,'t':dict_var.manual.t},\n  'p':current_position,\n
              \ 'v':4,\n  't':as_timestamp(now()) | round(0)\n  })\n%}\n{{ dict_new
              | to_json }}\n"
      - stop: 'Stop automation: Lockout-protection'
    - delay:
        seconds: '{{ range(drive_delay_fix|int(0), drive_delay_fix|int(0) + drive_delay_random|int(0)
          +1) | random }}'
    - if:
      - '{{ is_ventilation_enabled }}'
      - '{{ contact_sensor != [] }}'
      - '{{ is_state(contact_sensor, [''true'', ''on'']) }}'
      then:
      - if:
        - '{{ not prevent_default_cover_actions}}'
        then:
        - repeat:
            for_each: '{{ blind_entities|list }}'
            sequence:
            - alias: Moving the cover to ventilate position
              service: cover.set_cover_position
              data:
                position: !input ventilate_position
              target:
                entity_id: '{{ repeat.item }}'
            - if:
              - '{{ state_attr(repeat.item, ''current_tilt_position'') != none }}'
              then:
              - alias: Moving the cover to tilt position
                service: cover.set_cover_tilt_position
                data:
                  tilt_position: !input ventilate_tilt_position
                target:
                  entity_id: '{{ repeat.item }}'
            - alias: Wait 1-5 random seconds to prevent sending to many commands to
                covers at same time
              delay:
                seconds: '{{ (range(1, 3)|random|int) }}'
      - if:
        - '{{ ''cover_helper_enabled'' in cover_status_options }}'
        then:
        - service: input_text.set_value
          data:
            entity_id: !input cover_status_helper
            value: "{% set dict_var = states(cover_status_helper) | from_json %}\n{%
              set dict_new = dict(dict_var, **{\n  'open':{'a':false,'t':dict_var.open.t},\n
              \ 'close':{'a':false,'t':dict_var.close.t},\n  'ventilate':{'a':true,'t':as_timestamp(now())
              | round(0)},\n  'shading':{'a':false,'t':dict_var.shading.t},\n  'locked':{'a':false,'t':dict_var.locked.t},\n
              \ 'manual':{'a':false,'t':dict_var.manual.t},\n  'p':current_position,\n
              \ 'v':4,\n  't':as_timestamp(now()) | round(0)\n  })\n%}\n{{ dict_new
              | to_json }}\n"
      - choose: []
        default: !input auto_ventilate_action
      - stop: 'Stop automation: Moved to ventilation position during the closing process'
      else:
      - if:
        - '{{ not prevent_default_cover_actions}}'
        then:
        - repeat:
            for_each: '{{ blind_entities|list }}'
            sequence:
            - if:
              - '{{ close_position == 0 }}'
              then:
              - alias: Moving the cover to close position
                service: cover.close_cover
                data: {}
                target:
                  entity_id: '{{ repeat.item }}'
              else:
              - alias: Moving the cover to close position
                service: cover.set_cover_position
                data:
                  position: !input close_position
                target:
                  entity_id: '{{ repeat.item }}'
            - if:
              - '{{ state_attr(repeat.item, ''current_tilt_position'') != none }}'
              then:
              - alias: Moving the cover to tilt position
                service: cover.set_cover_tilt_position
                data:
                  tilt_position: !input close_tilt_position
                target:
                  entity_id: '{{ repeat.item }}'
            - alias: Wait 1-5 random seconds to prevent sending to many commands to
                covers at same time
              delay:
                seconds: '{{ (range(1, 3)|random|int) }}'
      - if:
        - '{{ ''cover_helper_enabled'' in cover_status_options }}'
        then:
        - service: input_text.set_value
          data:
            entity_id: !input cover_status_helper
            value: "{% set dict_var = states(cover_status_helper) | from_json %}\n{%
              set dict_new = dict(dict_var, **{\n  'open':{'a':false,'t':dict_var.open.t},\n
              \ 'close':{'a':true,'t':as_timestamp(now()) | round(0)},\n  'ventilate':{'a':false,'t':dict_var.ventilate.t},\n
              \ 'shading':{'a':false,'t':dict_var.shading.t},\n  'locked':{'a':false,'t':dict_var.locked.t},\n
              \ 'manual':{'a':false,'t':dict_var.manual.t},\n  'p':current_position,\n
              \ 'v':4,\n  't':as_timestamp(now()) | round(0)\n  })\n%}\n{{ dict_new
              | to_json }}\n"
      - choose: []
        default: !input auto_down_action
      - stop: 'Stop automation: Moved to closing position'
    - stop: 'Stop automation: Closing'
  - alias: Check for shading start
    conditions:
    - '{{ is_shading_enabled }}'
    - condition: !input auto_shading_start_condition
    - condition: trigger
      id:
      - t_si_1
      - t_bo_1
      - t_bo_3
    - '{{ auto_up_force == [] or auto_up_force != [] and is_state(auto_up_force, [''false'',
      ''off'']) }}'
    - '{{ auto_ventilate_force == [] or auto_ventilate_force != [] and is_state(auto_ventilate_force,
      [''false'', ''off'']) }}'
    - '{{ current_sun_azimuth > shading_azimuth_start and current_sun_azimuth < shading_azimuth_end
      }}'
    - '{{ current_sun_elevation > shading_elevation_min and current_sun_elevation
      < shading_elevation_max }}'
    - '{{ current_position | int(default=101) > shading_position }}'
    - or:
      - '{{ not is_status_helper_enabled }}'
      - '{{ is_status_helper_enabled and not is_cover_shaded }}'
      - '{{ is_status_helper_enabled and not (is_cover_ventilated or is_cover_locked)
        }}'
    - or:
      - '{{ not is_status_helper_enabled }}'
      - '{{ is_status_helper_enabled and not is_cover_manual }}'
      - '{{ is_status_helper_enabled and ignore_shading_after_manual }}'
      - '{{ is_status_helper_enabled and is_cover_manual and not ignore_shading_after_manual
        }}'
    - or:
      - '{{ not is_status_helper_enabled }}'
      - '{{ allow_shading_multiple_times }}'
      - '{{ is_status_helper_enabled and (now().day != is_cover_shaded_ts|timestamp_custom(''%-d'')|int)
        }}'
    - or:
      - and:
        - '{{ is_time_field_enabled }}'
        - '{{ now() >= today_at(time_up_early_today) }}'
        - '{{ now() <= today_at(time_down_late_today) + timedelta(seconds = 5) }}'
      - and:
        - '{{ is_schedule_helper_enabled }}'
        - '{{ time_schedule_helper != [] }}'
        - '{{ is_state(time_schedule_helper, ''on'') }}'
    - or:
      - '{{ shading_temperatur_sensor1 == [] }}'
      - '{{ states(shading_temperatur_sensor1) | float(default=shading_min_temperatur1)
        > shading_min_temperatur1 }}'
    - or:
      - '{{ shading_temperatur_sensor2 == [] }}'
      - '{{ states(shading_temperatur_sensor2) | float(default=shading_min_temperatur2)
        > shading_min_temperatur2 }}'
    - or:
      - '{{ shading_brightness_sensor == [] }}'
      - '{{ states(shading_brightness_sensor) | float(default=shading_sun_brightness_start)
        > shading_sun_brightness_start }}'
    - or:
      - '{{ prevent_forecast_service }}'
      - '{{ shading_forecast_sensor == [] }}'
      - '{{ shading_forecast_temp == [] }}'
      - '{{ (not prevent_forecast_service) and weather_forecast[shading_forecast_sensor].forecast[0].temperature
        | float(default=shading_forecast_temp) > shading_forecast_temp }}'
    - or:
      - '{{ prevent_forecast_service }}'
      - '{{ shading_forecast_sensor == [] }}'
      - '{{ shading_weather_conditions == [] }}'
      - '{{ (not prevent_forecast_service) and weather_forecast[shading_forecast_sensor].forecast[0].condition
        in shading_weather_conditions }}'
    - or:
      - '{{ resident_sensor == [] }}'
      - '{{ is_state(resident_sensor, [''false'', ''off'']) }}'
    sequence:
    - if:
      - or:
        - '{{ is_status_helper_enabled and (now().day != is_cover_shaded_ts|timestamp_custom(''%-d'')|int)
          and not is_cover_shaded }}'
        - '{{ is_ventilation_enabled and (current_position | int(default=101) > ventilate_position)
          }}'
        - '{{ not is_ventilation_enabled and (current_position | int(default=101)
          > shading_position) }}'
      then:
      - alias: Wait the number of seconds set in shading_waitingtime
        delay:
          seconds: !input shading_waitingtime_start
    - delay:
        seconds: '{{ range(drive_delay_fix|int(0), drive_delay_fix|int(0) + drive_delay_random|int(0)
          +1) | random }}'
    - if:
      - '{{ not prevent_default_cover_actions}}'
      then:
      - repeat:
          for_each: '{{ blind_entities|list }}'
          sequence:
          - alias: Moving the cover to shading position
            service: cover.set_cover_position
            data:
              position: !input shading_position
            target:
              entity_id: '{{ repeat.item }}'
          - if:
            - '{{ state_attr(repeat.item, ''current_tilt_position'') != none }}'
            then:
            - alias: Moving the cover to tilt position
              service: cover.set_cover_tilt_position
              data:
                tilt_position: !input shading_tilt_position
              target:
                entity_id: '{{ repeat.item }}'
          - alias: Wait 1-5 random seconds to prevent sending to many commands to
              covers at same time
            delay:
              seconds: '{{ (range(1, 3)|random|int) }}'
    - if:
      - '{{ ''cover_helper_enabled'' in cover_status_options }}'
      then:
      - service: input_text.set_value
        data:
          entity_id: !input cover_status_helper
          value: "{% set dict_var = states(cover_status_helper) | from_json %}\n{%
            set dict_new = dict(dict_var, **{\n  'open':{'a':false,'t':dict_var.open.t},\n
            \ 'close':{'a':false,'t':dict_var.close.t},\n  'ventilate':{'a':false,'t':dict_var.ventilate.t},\n
            \ 'shading':{'a':true,'t':as_timestamp(now()) | round(0)},\n  'locked':{'a':false,'t':dict_var.locked.t},\n
            \ 'manual':{'a':false,'t':dict_var.manual.t},\n  'p':current_position,\n
            \ 'v':4,\n  't':as_timestamp(now()) | round(0)\n  })\n%}\n{{ dict_new
            | to_json }}\n"
    - choose: []
      default: !input auto_shading_start_action
    - stop: 'Stop automation: Shading-start'
  - alias: Check for shading end
    conditions:
    - '{{ is_shading_enabled }}'
    - condition: !input auto_shading_end_condition
    - condition: trigger
      id:
      - t_so_1
      - t_so_2
      - t_so_3
      - t_so_4
      - t_so_5
      - t_so_6
    - '{{ auto_down_force == [] or auto_down_force != [] and is_state(auto_down_force,
      [''false'', ''off'']) }}'
    - or:
      - and:
        - '{{ is_time_field_enabled }}'
        - '{{ now() >= today_at(time_up_early_today) }}'
        - '{{ now() <= today_at(time_down_late_today) + timedelta(seconds = 5) }}'
      - and:
        - '{{ is_schedule_helper_enabled }}'
        - '{{ time_schedule_helper != [] }}'
        - '{{ is_state(time_schedule_helper, ''on'') }}'
    - or:
      - '{{ not is_status_helper_enabled }}'
      - '{{ is_status_helper_enabled and not is_cover_manual }}'
      - '{{ is_status_helper_enabled and ignore_shading_after_manual }}'
      - '{{ is_status_helper_enabled and is_cover_manual and not ignore_shading_after_manual
        }}'
    - or:
      - '{{ is_status_helper_enabled and is_cover_shaded }}'
      - '{{ in_shading_position }}'
    - or:
      - '{{ not prevent_shading_end_if_closed }}'
      - or:
        - and:
          - '{{ is_status_helper_enabled }}'
          - '{{ prevent_shading_end_if_closed }}'
          - '{{ not is_cover_closed }}'
        - and:
          - '{{ prevent_shading_end_if_closed }}'
          - '{{ not in_close_position }}'
    sequence:
    - if:
      - and:
        - '{{ current_sun_azimuth > shading_azimuth_start and current_sun_azimuth
          < shading_azimuth_end }}'
        - '{{ current_sun_elevation > shading_elevation_min and current_sun_elevation
          < shading_elevation_max }}'
      then:
      - alias: Wait the number of seconds set in shading_waitingtime_end
        delay:
          seconds: !input shading_waitingtime_end
    - if:
      - '{{ is_ventilation_enabled }}'
      - '{{ contact_sensor != [] and is_state(contact_sensor, [''true'', ''on''])
        }}'
      then:
      - if:
        - '{{ not prevent_default_cover_actions}}'
        then:
        - repeat:
            for_each: '{{ blind_entities|list }}'
            sequence:
            - alias: Moving the cover to ventilate position
              service: cover.set_cover_position
              data:
                position: !input ventilate_position
              target:
                entity_id: '{{ repeat.item }}'
            - if:
              - '{{ state_attr(repeat.item, ''current_tilt_position'') != none }}'
              then:
              - alias: Moving the cover to tilt position
                service: cover.set_cover_tilt_position
                data:
                  tilt_position: !input ventilate_tilt_position
                target:
                  entity_id: '{{ repeat.item }}'
            - alias: Wait 1-5 random seconds to prevent sending to many commands to
                covers at same time
              delay:
                seconds: '{{ (range(1, 3)|random|int) }}'
      - if:
        - '{{ ''cover_helper_enabled'' in cover_status_options }}'
        then:
        - service: input_text.set_value
          data:
            entity_id: !input cover_status_helper
            value: "{% set dict_var = states(cover_status_helper) | from_json %}\n{%
              set dict_new = dict(dict_var, **{\n  'open':{'a':false,'t':dict_var.open.t},\n
              \ 'close':{'a':false,'t':dict_var.close.t},\n  'ventilate':{'a':true,'t':as_timestamp(now())
              | round(0)},\n  'shading':{'a':false,'t':dict_var.shading.t},\n  'locked':{'a':false,'t':dict_var.locked.t},\n
              \ 'manual':{'a':false,'t':dict_var.manual.t},\n  'p':current_position,\n
              \ 'v':4,\n  't':as_timestamp(now()) | round(0)\n  })\n%}\n{{ dict_new
              | to_json }}\n"
      - choose: []
        default: !input auto_ventilate_action
      else:
      - if:
        - '{{ not prevent_default_cover_actions}}'
        then:
        - repeat:
            for_each: '{{ blind_entities|list }}'
            sequence:
            - if:
              - '{{ open_position == 100 }}'
              then:
              - alias: Moving the cover to open position
                service: cover.open_cover
                data: {}
                target:
                  entity_id: '{{ repeat.item }}'
              else:
              - alias: Moving the cover to open position
                service: cover.set_cover_position
                data:
                  position: !input open_position
                target:
                  entity_id: '{{ repeat.item }}'
            - if:
              - '{{ state_attr(repeat.item, ''current_tilt_position'') != none }}'
              then:
              - alias: Moving the cover to tilt position
                service: cover.set_cover_tilt_position
                data:
                  tilt_position: !input open_tilt_position
                target:
                  entity_id: '{{ repeat.item }}'
            - alias: Wait 1-5 random seconds to prevent sending to many commands to
                covers at same time
              delay:
                seconds: '{{ (range(1, 3)|random|int) }}'
      - if:
        - '{{ ''cover_helper_enabled'' in cover_status_options }}'
        then:
        - service: input_text.set_value
          data:
            entity_id: !input cover_status_helper
            value: "{% set dict_var = states(cover_status_helper) | from_json %}\n{%
              set dict_new = dict(dict_var, **{\n  'open':{'a':true,'t':as_timestamp(now())
              | round(0)},\n  'close':{'a':false,'t':dict_var.close.t},\n  'ventilate':{'a':false,'t':dict_var.ventilate.t},\n
              \ 'shading':{'a':false,'t':dict_var.shading.t},\n  'locked':{'a':false,'t':dict_var.locked.t},\n
              \ 'manual':{'a':false,'t':dict_var.manual.t},\n  'p':current_position,\n
              \ 'v':4,\n  't':as_timestamp(now()) | round(0)\n  })\n%}\n{{ dict_new
              | to_json }}\n"
      - choose: []
        default: !input auto_shading_end_action
    - stop: 'Stop automation: Shading-end'
  - alias: Contact sensor opened
    conditions:
    - '{{ is_ventilation_enabled }}'
    - condition: !input auto_ventilate_condition
    - condition: trigger
      id: t_co_open
    - '{{ contact_sensor != [] }}'
    - '{{ is_state(contact_sensor, [''true'', ''on'']) }}'
    - '{{ auto_down_force == [] or auto_down_force != [] and is_state(auto_down_force,
      [''false'', ''off'']) }}'
    - or:
      - '{{ is_status_helper_enabled and is_cover_closed }}'
      - '{{ in_close_position }}'
      - '{{ ventilation_if_lower_enabled and (current_position | int(default=101)
        < ventilate_position) }}'
    sequence:
    - if:
      - '{{ not prevent_default_cover_actions}}'
      then:
      - repeat:
          for_each: '{{ blind_entities|list }}'
          sequence:
          - alias: Moving the cover to ventilate position
            service: cover.set_cover_position
            data:
              position: !input ventilate_position
            target:
              entity_id: '{{ repeat.item }}'
          - if:
            - '{{ state_attr(repeat.item, ''current_tilt_position'') != none }}'
            then:
            - alias: Moving the cover to tilt position
              service: cover.set_cover_tilt_position
              data:
                tilt_position: !input ventilate_tilt_position
              target:
                entity_id: '{{ repeat.item }}'
          - alias: Wait 1-5 random seconds to prevent sending to many commands to
              covers at same time
            delay:
              seconds: '{{ (range(1, 3)|random|int) }}'
    - if:
      - '{{ ''cover_helper_enabled'' in cover_status_options }}'
      then:
      - service: input_text.set_value
        data:
          entity_id: !input cover_status_helper
          value: "{% set dict_var = states(cover_status_helper) | from_json %}\n{%
            set dict_new = dict(dict_var, **{\n  'open':{'a':false,'t':dict_var.open.t},\n
            \ 'close':{'a':false,'t':dict_var.close.t},\n  'ventilate':{'a':true,'t':as_timestamp(now())
            | round(0)},\n  'shading':{'a':false,'t':dict_var.shading.t},\n  'locked':{'a':false,'t':dict_var.locked.t},\n
            \ 'manual':{'a':false,'t':dict_var.manual.t},\n  'p':current_position,\n
            \ 'v':4,\n  't':as_timestamp(now()) | round(0)\n  })\n%}\n{{ dict_new
            | to_json }}\n"
    - choose: []
      default: !input auto_ventilate_action
    - stop: 'Stop automation: Contact sensor has been opened'
  - alias: Contact sensor closed / Closing after ventilation and after lockout-protection
    conditions:
    - or:
      - '{{ is_ventilation_enabled }}'
      - '{{ is_lockout_protection_enabled and not prevent_close_after_lockout }}'
    - condition: trigger
      id: t_co_close
    - '{{ contact_sensor != [] }}'
    - '{{ is_state(contact_sensor, [''false'', ''off'']) }}'
    - '{{ auto_up_force == [] or auto_up_force != [] and is_state(auto_up_force, [''false'',
      ''off'']) }}'
    - '{{ auto_ventilate_force == [] or auto_ventilate_force != [] and is_state(auto_ventilate_force,
      [''false'', ''off'']) }}'
    - or:
      - '{{ is_status_helper_enabled and (is_cover_ventilated or is_cover_locked)
        }}'
      - '{{ in_ventilate_position }}'
    - or:
      - '{{ not is_status_helper_enabled }}'
      - '{{ is_status_helper_enabled and not is_cover_manual }}'
      - '{{ is_status_helper_enabled and ignore_ventilation_after_manual }}'
      - '{{ is_status_helper_enabled and is_cover_manual and not ignore_ventilation_after_manual
        }}'
    - or:
      - and:
        - '{{ is_schedule_helper_enabled }}'
        - '{{ time_schedule_helper != [] }}'
        - '{{ is_state(time_schedule_helper, ''off'') }}'
      - and:
        - '{{ is_time_field_enabled }}'
        - '{{ now() <= today_at(time_up_early_today) }}'
      - and:
        - '{{ is_time_field_enabled }}'
        - '{{ now() >= today_at(time_down_late_today) }}'
      - and:
        - or:
          - and:
            - '{{ is_time_field_enabled }}'
            - '{{ now() >= today_at(time_up_early_today) }}'
            - '{{ now() <= today_at(time_up_late_today) }}'
          - and:
            - '{{ is_schedule_helper_enabled }}'
            - '{{ time_schedule_helper != [] }}'
            - '{{ is_state(time_schedule_helper, ''on'') }}'
        - or:
          - or:
            - '{{ is_brightness_enabled and default_brightness_sensor == [] }}'
            - '{{ is_brightness_enabled and default_brightness_sensor != [] and (states(default_brightness_sensor)
              | float(default=brightness_up) < brightness_up) }}'
          - or:
            - '{{ is_sun_elevation_enabled and default_sun_sensor == [] }}'
            - '{{ is_sun_elevation_enabled and default_sun_sensor != [] and (current_sun_elevation
              | float(default=sun_elevation_up) < sun_elevation_up) }}'
      - and:
        - or:
          - and:
            - '{{ is_time_field_enabled }}'
            - '{{ now() >= today_at(time_down_early_today) }}'
            - '{{ now() <= today_at(time_down_late_today) + timedelta(seconds = 5)
              }}'
          - and:
            - '{{ is_schedule_helper_enabled }}'
            - '{{ time_schedule_helper != [] }}'
            - '{{ is_state(time_schedule_helper, ''on'') }}'
        - or:
          - or:
            - '{{ is_brightness_enabled and default_brightness_sensor == [] }}'
            - '{{ is_brightness_enabled and default_brightness_sensor != [] and (states(default_brightness_sensor)
              | float(default=brightness_down) < brightness_down) }}'
          - or:
            - '{{ is_sun_elevation_enabled and default_sun_sensor == [] }}'
            - '{{ is_sun_elevation_enabled and default_sun_sensor != [] and (current_sun_elevation
              | float(default=sun_elevation_down) < sun_elevation_down) }}'
    sequence:
    - if:
      - '{{ ventilation_delay_enabled }}'
      then:
      - delay:
          seconds: '{{ range(drive_delay_fix|int(0), drive_delay_fix|int(0) + drive_delay_random|int(0)
            +1) | random }}'
    - if:
      - '{{ not prevent_default_cover_actions}}'
      then:
      - repeat:
          for_each: '{{ blind_entities|list }}'
          sequence:
          - if:
            - '{{ close_position == 0 }}'
            then:
            - alias: Moving the cover to close position
              service: cover.close_cover
              data: {}
              target:
                entity_id: '{{ repeat.item }}'
            else:
            - alias: Moving the cover to close position
              service: cover.set_cover_position
              data:
                position: !input close_position
              target:
                entity_id: '{{ repeat.item }}'
          - if:
            - '{{ state_attr(repeat.item, ''current_tilt_position'') != none }}'
            then:
            - alias: Moving the cover to tilt position
              service: cover.set_cover_tilt_position
              data:
                tilt_position: !input close_tilt_position
              target:
                entity_id: '{{ repeat.item }}'
          - alias: Wait 1-5 random seconds to prevent sending to many commands to
              covers at same time
            delay:
              seconds: '{{ (range(1, 3)|random|int) }}'
    - if:
      - '{{ ''cover_helper_enabled'' in cover_status_options }}'
      then:
      - service: input_text.set_value
        data:
          entity_id: !input cover_status_helper
          value: "{% set dict_var = states(cover_status_helper) | from_json %}\n{%
            set dict_new = dict(dict_var, **{\n  'open':{'a':false,'t':dict_var.open.t},\n
            \ 'close':{'a':true,'t':as_timestamp(now()) | round(0)},\n  'ventilate':{'a':false,'t':dict_var.ventilate.t},\n
            \ 'shading':{'a':false,'t':dict_var.shading.t},\n  'locked':{'a':false,'t':dict_var.locked.t},\n
            \ 'manual':{'a':false,'t':dict_var.manual.t},\n  'p':current_position,\n
            \ 'v':4,\n  't':as_timestamp(now()) | round(0)\n  })\n%}\n{{ dict_new
            | to_json }}\n"
    - choose: []
      default: !input auto_down_action
    - stop: 'Stop automation: Closing after ventilation and after lockout-protection'
  - alias: Forced opening of the cover
    conditions:
    - '{{ is_up_enabled }}'
    - condition: trigger
      id: t_bo_force
    - '{{ auto_up_force != [] and is_state(auto_up_force, [''true'', ''on'']) }}'
    sequence:
    - if:
      - '{{ not prevent_default_cover_actions}}'
      then:
      - repeat:
          for_each: '{{ blind_entities|list }}'
          sequence:
          - if:
            - '{{ open_position == 100 }}'
            then:
            - alias: Moving the cover to open position
              service: cover.open_cover
              data: {}
              target:
                entity_id: '{{ repeat.item }}'
            else:
            - alias: Moving the cover to open position
              service: cover.set_cover_position
              data:
                position: !input open_position
              target:
                entity_id: '{{ repeat.item }}'
          - if:
            - '{{ state_attr(repeat.item, ''current_tilt_position'') != none }}'
            then:
            - alias: Moving the cover to tilt position
              service: cover.set_cover_tilt_position
              data:
                tilt_position: !input open_tilt_position
              target:
                entity_id: '{{ repeat.item }}'
          - alias: Wait 1-5 random seconds to prevent sending to many commands to
              covers at same time
            delay:
              seconds: '{{ (range(1, 3)|random|int) }}'
    - if:
      - '{{ ''cover_helper_enabled'' in cover_status_options }}'
      then:
      - service: input_text.set_value
        data:
          entity_id: !input cover_status_helper
          value: "{% set dict_var = states(cover_status_helper) | from_json %}\n{%
            set dict_new = dict(dict_var, **{\n  'open':{'a':true,'t':as_timestamp(now())
            | round(0)},\n  'close':{'a':false,'t':dict_var.close.t},\n  'ventilate':{'a':false,'t':dict_var.ventilate.t},\n
            \ 'shading':{'a':false,'t':dict_var.shading.t},\n  'locked':{'a':false,'t':dict_var.locked.t},\n
            \ 'manual':{'a':false,'t':dict_var.manual.t},\n  'p':current_position,\n
            \ 'v':4,\n  't':as_timestamp(now()) | round(0)\n  })\n%}\n{{ dict_new
            | to_json }}\n"
    - choose: []
      default: !input auto_up_action
    - stop: 'Stop automation: Forced Opening'
  - alias: Forced closing of the cover
    conditions:
    - '{{ is_down_enabled }}'
    - condition: trigger
      id: t_bc_force
    - '{{ auto_down_force != [] and is_state(auto_down_force, [''true'', ''on''])
      }}'
    sequence:
    - if:
      - '{{ not prevent_default_cover_actions}}'
      then:
      - repeat:
          for_each: '{{ blind_entities|list }}'
          sequence:
          - if:
            - '{{ close_position == 0 }}'
            then:
            - alias: Moving the cover to close position
              service: cover.close_cover
              data: {}
              target:
                entity_id: '{{ repeat.item }}'
            else:
            - alias: Moving the cover to close position
              service: cover.set_cover_position
              data:
                position: !input close_position
              target:
                entity_id: '{{ repeat.item }}'
          - if:
            - '{{ state_attr(repeat.item, ''current_tilt_position'') != none }}'
            then:
            - alias: Moving the cover to tilt position
              service: cover.set_cover_tilt_position
              data:
                tilt_position: !input close_tilt_position
              target:
                entity_id: '{{ repeat.item }}'
          - alias: Wait 1-5 random seconds to prevent sending to many commands to
              covers at same time
            delay:
              seconds: '{{ (range(1, 3)|random|int) }}'
    - if:
      - '{{ ''cover_helper_enabled'' in cover_status_options }}'
      then:
      - service: input_text.set_value
        data:
          entity_id: !input cover_status_helper
          value: "{% set dict_var = states(cover_status_helper) | from_json %}\n{%
            set dict_new = dict(dict_var, **{\n  'open':{'a':false,'t':dict_var.open.t},\n
            \ 'close':{'a':true,'t':as_timestamp(now()) | round(0)},\n  'ventilate':{'a':false,'t':dict_var.ventilate.t},\n
            \ 'shading':{'a':false,'t':dict_var.shading.t},\n  'locked':{'a':false,'t':dict_var.locked.t},\n
            \ 'manual':{'a':false,'t':dict_var.manual.t},\n  'p':current_position,\n
            \ 'v':4,\n  't':as_timestamp(now()) | round(0)\n  })\n%}\n{{ dict_new
            | to_json }}\n"
    - choose: []
      default: !input auto_down_action
    - stop: 'Stop automation: Forced Closing'
  - alias: Forced ventilation of the cover
    conditions:
    - '{{ is_ventilation_enabled }}'
    - condition: trigger
      id: t_co_force
    - '{{ auto_ventilate_force != [] and is_state(auto_ventilate_force, [''true'',
      ''on'']) }}'
    sequence:
    - if:
      - '{{ not prevent_default_cover_actions}}'
      then:
      - repeat:
          for_each: '{{ blind_entities|list }}'
          sequence:
          - alias: Moving the cover to ventilate position
            service: cover.set_cover_position
            data:
              position: !input ventilate_position
            target:
              entity_id: '{{ repeat.item }}'
          - if:
            - '{{ state_attr(repeat.item, ''current_tilt_position'') != none }}'
            then:
            - alias: Moving the cover to tilt position
              service: cover.set_cover_tilt_position
              data:
                tilt_position: !input ventilate_tilt_position
              target:
                entity_id: '{{ repeat.item }}'
          - alias: Wait 1-5 random seconds to prevent sending to many commands to
              covers at same time
            delay:
              seconds: '{{ (range(1, 3)|random|int) }}'
    - if:
      - '{{ ''cover_helper_enabled'' in cover_status_options }}'
      then:
      - service: input_text.set_value
        data:
          entity_id: !input cover_status_helper
          value: "{% set dict_var = states(cover_status_helper) | from_json %}\n{%
            set dict_new = dict(dict_var, **{\n  'open':{'a':false,'t':dict_var.open.t},\n
            \ 'close':{'a':false,'t':dict_var.close.t},\n  'ventilate':{'a':true,'t':as_timestamp(now())
            | round(0)},\n  'shading':{'a':false,'t':dict_var.shading.t},\n  'locked':{'a':false,'t':dict_var.locked.t},\n
            \ 'manual':{'a':false,'t':dict_var.manual.t},\n  'p':current_position,\n
            \ 'v':4,\n  't':as_timestamp(now()) | round(0)\n  })\n%}\n{{ dict_new
            | to_json }}\n"
    - choose: []
      default: !input auto_ventilate_action
    - stop: 'Stop automation: Forced Ventilation'
  - alias: Forced activating of the sun shading
    conditions:
    - '{{ is_shading_enabled }}'
    - condition: trigger
      id: t_si_force
    - '{{ auto_shading_start_force != [] and is_state(auto_shading_start_force, [''true'',
      ''on'']) }}'
    sequence:
    - if:
      - '{{ not prevent_default_cover_actions}}'
      then:
      - repeat:
          for_each: '{{ blind_entities|list }}'
          sequence:
          - alias: Moving the cover to shading position
            service: cover.set_cover_position
            data:
              position: !input shading_position
            target:
              entity_id: '{{ repeat.item }}'
          - if:
            - '{{ state_attr(repeat.item, ''current_tilt_position'') != none }}'
            then:
            - alias: Moving the cover to tilt position
              service: cover.set_cover_tilt_position
              data:
                tilt_position: !input shading_tilt_position
              target:
                entity_id: '{{ repeat.item }}'
          - alias: Wait 1-5 random seconds to prevent sending to many commands to
              covers at same time
            delay:
              seconds: '{{ (range(1, 3)|random|int) }}'
    - if:
      - '{{ ''cover_helper_enabled'' in cover_status_options }}'
      then:
      - service: input_text.set_value
        data:
          entity_id: !input cover_status_helper
          value: "{% set dict_var = states(cover_status_helper) | from_json %}\n{%
            set dict_new = dict(dict_var, **{\n  'open':{'a':false,'t':dict_var.open.t},\n
            \ 'close':{'a':false,'t':dict_var.close.t},\n  'ventilate':{'a':false,'t':dict_var.ventilate.t},\n
            \ 'shading':{'a':true,'t':as_timestamp(now()) | round(0)},\n  'locked':{'a':false,'t':dict_var.locked.t},\n
            \ 'manual':{'a':false,'t':dict_var.manual.t},\n  'p':current_position,\n
            \ 'v':4,\n  't':as_timestamp(now()) | round(0)\n  })\n%}\n{{ dict_new
            | to_json }}\n"
    - choose: []
      default: !input auto_shading_start_action
    - stop: 'Stop automation: Forced Shading-start'
  - alias: Cover movement - Checking for manual position changes
    conditions:
    - '{{ ''cover_helper_enabled'' in cover_status_options }}'
    - '{{ cover_status_helper != [] }}'
    - '{{ as_timestamp(now()) > cover_status_time + drive_time + 60 }}'
    - condition: trigger
      id: t_ma_1
    - '{{ is_number(trigger.to_state.attributes.current_position) and is_number(trigger.from_state.attributes.current_position)
      }}'
    - '{{ trigger.to_state.attributes.current_position != trigger.from_state.attributes.current_position
      }}'
    sequence:
    - choose:
      - conditions:
        - not:
          - '{{ is_up_enabled and in_open_position }}'
          - '{{ is_down_enabled and in_close_position }}'
          - '{{ is_ventilation_enabled and in_ventilate_position }}'
          - '{{ is_shading_enabled and in_shading_position }}'
        sequence:
        - service: input_text.set_value
          data:
            entity_id: !input cover_status_helper
            value: "{% set dict_var = states(cover_status_helper) | from_json %}\n{%
              set dict_new = dict(dict_var, **{\n  'open':{'a':false,'t':dict_var.open.t},\n
              \ 'close':{'a':false,'t':dict_var.close.t},\n  'ventilate':{'a':false,'t':dict_var.ventilate.t},\n
              \ 'shading':{'a':false,'t':dict_var.shading.t},\n  'locked':{'a':false,'t':dict_var.locked.t},\n
              \ 'manual':{'a':true,'t':as_timestamp(now()) | round(0)},\n  'p':current_position,\n
              \ 'v':4,\n  't':as_timestamp(now()) | round(0)\n  })\n%}\n{{ dict_new
              | to_json }}\n"
      - conditions:
        - '{{ is_up_enabled }}'
        - or:
          - '{{ in_open_position }}'
          - '{{ (current_position | int(default=101) > ventilate_position) }}'
          - '{{ (current_position | int(default=101) >= open_position) }}'
          - '{{ (current_position | int(default=101) == 100) }}'
        sequence:
        - service: input_text.set_value
          data:
            entity_id: !input cover_status_helper
            value: "{% set dict_var = states(cover_status_helper) | from_json %}\n{%
              set dict_new = dict(dict_var, **{\n  'open':{'a':true,'t':as_timestamp(now())
              | round(0)},\n  'close':{'a':false,'t':dict_var.close.t},\n  'ventilate':{'a':false,'t':dict_var.ventilate.t},\n
              \ 'shading':{'a':false,'t':dict_var.shading.t},\n  'locked':{'a':false,'t':dict_var.locked.t},\n
              \ 'manual':{'a':true,'t':as_timestamp(now()) | round(0)},\n  'p':current_position,\n
              \ 'v':4,\n  't':as_timestamp(now()) | round(0)\n  })\n%}\n{{ dict_new
              | to_json }}\n"
      - conditions:
        - '{{ is_down_enabled }}'
        - or:
          - '{{ in_close_position }}'
          - '{{ (current_position | int(default=101) < shading_position) and (current_position
            | int(default=101) < ventilate_position) }}'
          - '{{ (current_position | int(default=101) <= close_position) }}'
          - '{{ (current_position | int(default=101) == 0) }}'
        sequence:
        - service: input_text.set_value
          data:
            entity_id: !input cover_status_helper
            value: "{% set dict_var = states(cover_status_helper) | from_json %}\n{%
              set dict_new = dict(dict_var, **{\n  'open':{'a':false,'t':dict_var.open.t},\n
              \ 'close':{'a':true,'t':as_timestamp(now()) | round(0)},\n  'ventilate':{'a':false,'t':dict_var.ventilate.t},\n
              \ 'shading':{'a':false,'t':dict_var.shading.t},\n  'locked':{'a':false,'t':dict_var.locked.t},\n
              \ 'manual':{'a':true,'t':as_timestamp(now()) | round(0)},\n  'p':current_position,\n
              \ 'v':4,\n  't':as_timestamp(now()) | round(0)\n  })\n%}\n{{ dict_new
              | to_json }}\n"
      - conditions:
        - '{{ is_ventilation_enabled }}'
        - '{{ in_ventilate_position }}'
        - '{{ not in_open_position }}'
        sequence:
        - service: input_text.set_value
          data:
            entity_id: !input cover_status_helper
            value: "{% set dict_var = states(cover_status_helper) | from_json %}\n{%
              set dict_new = dict(dict_var, **{\n  'open':{'a':false,'t':dict_var.open.t},\n
              \ 'close':{'a':false,'t':dict_var.close.t},\n  'ventilate':{'a':true,'t':as_timestamp(now())
              | round(0)},\n  'shading':{'a':false,'t':dict_var.shading.t},\n  'locked':{'a':false,'t':dict_var.locked.t},\n
              \ 'manual':{'a':true,'t':as_timestamp(now()) | round(0)},\n  'p':current_position,\n
              \ 'v':4,\n  't':as_timestamp(now()) | round(0)\n  })\n%}\n{{ dict_new
              | to_json }}\n"
      - conditions:
        - '{{ is_shading_enabled }}'
        - '{{ in_shading_position }}'
        sequence:
        - service: input_text.set_value
          data:
            entity_id: !input cover_status_helper
            value: "{% set dict_var = states(cover_status_helper) | from_json %}\n{%
              set dict_new = dict(dict_var, **{\n  'open':{'a':false,'t':dict_var.open.t},\n
              \ 'close':{'a':false,'t':dict_var.close.t},\n  'ventilate':{'a':false,'t':dict_var.ventilate.t},\n
              \ 'shading':{'a':true,'t':as_timestamp(now()) | round(0)},\n  'locked':{'a':false,'t':dict_var.locked.t},\n
              \ 'manual':{'a':true,'t':as_timestamp(now()) | round(0)},\n  'p':current_position,\n
              \ 'v':4,\n  't':as_timestamp(now()) | round(0)\n  })\n%}\n{{ dict_new
              | to_json }}\n"
  default:
  - if:
    - '{{ check_config }}'
    then:
    - if:
      - '{{ today_at(time_up_early) >= today_at(time_up_late) }}'
      then:
      - service: system_log.write
        data:
          level: '{{ check_config_debuglevel }}'
          message: 'Cover Control Automation (CCA): Config issue: time_up_early should
            be earlier than time_up_late - {{this.entity_id}}'
          logger: blueprints.hvorragend.cover_control_automation
    - if:
      - '{{ today_at(time_up_early_non_workday) >= today_at(time_up_late_non_workday)
        }}'
      then:
      - service: system_log.write
        data:
          level: '{{ check_config_debuglevel }}'
          message: 'Cover Control Automation (CCA): Config issue: time_up_early_non_workday
            should be earlier than time_up_late_non_workday - {{this.entity_id}}'
          logger: blueprints.hvorragend.cover_control_automation
    - if:
      - '{{ today_at(time_down_early) >= today_at(time_down_late) }}'
      then:
      - service: system_log.write
        data:
          level: '{{ check_config_debuglevel }}'
          message: 'Cover Control Automation (CCA): Config issue: time_down_early
            should be earlier than time_down_late - {{this.entity_id}}'
          logger: blueprints.hvorragend.cover_control_automation
    - if:
      - '{{ today_at(time_down_early_non_workday) >= today_at(time_down_late_non_workday)
        }}'
      then:
      - service: system_log.write
        data:
          level: '{{ check_config_debuglevel }}'
          message: 'Cover Control Automation (CCA): Config issue: time_down_early_non_workday
            should be earlier than time_down_late_non_workday - {{this.entity_id}}'
          logger: blueprints.hvorragend.cover_control_automation
    - if:
      - '{{ shading_azimuth_start >= shading_azimuth_end }}'
      then:
      - service: system_log.write
        data:
          level: '{{ check_config_debuglevel }}'
          message: 'Cover Control Automation (CCA): Config issue: shading_azimuth_start
            should be lower than shading_azimuth_end - {{this.entity_id}}'
          logger: blueprints.hvorragend.cover_control_automation
    - if:
      - '{{ shading_elevation_min >= shading_elevation_max }}'
      then:
      - service: system_log.write
        data:
          level: '{{ check_config_debuglevel }}'
          message: 'Cover Control Automation (CCA): Config issue: shading_elevation_min
            should be lower than - {{this.entity_id}}'
          logger: blueprints.hvorragend.cover_control_automation
    - if:
      - '{{ shading_sun_brightness_start <= shading_sun_brightness_end }}'
      then:
      - service: system_log.write
        data:
          level: '{{ check_config_debuglevel }}'
          message: 'Cover Control Automation (CCA): Config issue: shading_sun_brightness_start
            should be higher than shading_sun_brightness_end - {{this.entity_id}}'
          logger: blueprints.hvorragend.cover_control_automation
    - if:
      - '{{ (open_position - position_tolerance) <= (close_position + position_tolerance)
        }}'
      then:
      - service: system_log.write
        data:
          level: '{{ check_config_debuglevel }}'
          message: 'Cover Control Automation (CCA): Config issue: open_position should
            be higher than close_position - {{this.entity_id}}'
          logger: blueprints.hvorragend.cover_control_automation
    - if:
      - '{{ (open_position - position_tolerance) <= (ventilate_position + position_tolerance)
        }}'
      then:
      - service: system_log.write
        data:
          level: '{{ check_config_debuglevel }}'
          message: 'Cover Control Automation (CCA): Config issue: open_position should
            be higher than ventilate_position - {{this.entity_id}}'
          logger: blueprints.hvorragend.cover_control_automation
    - if:
      - '{{ (close_position + position_tolerance) >= (ventilate_position - position_tolerance)
        }}'
      then:
      - service: system_log.write
        data:
          level: '{{ check_config_debuglevel }}'
          message: 'Cover Control Automation (CCA): Config issue: close_position should
            be lower than ventilate_position - {{this.entity_id}}'
          logger: blueprints.hvorragend.cover_control_automation
    - if:
      - '{{ (shading_position - position_tolerance) <= (close_position + position_tolerance)}}'
      then:
      - service: system_log.write
        data:
          level: '{{ check_config_debuglevel }}'
          message: 'Cover Control Automation (CCA): Config issue: shading_position
            should be higher than close_position - {{this.entity_id}}'
          logger: blueprints.hvorragend.cover_control_automation
    - if:
      - '{{ (shading_position + position_tolerance) >= (open_position - position_tolerance)
        }}'
      then:
      - service: system_log.write
        data:
          level: '{{ check_config_debuglevel }}'
          message: 'Cover Control Automation (CCA): Config issue: shading_position
            should be lower than open_position - {{this.entity_id}}'
          logger: blueprints.hvorragend.cover_control_automation
    - if:
      - '{{ ( (resident_sensor != [] ) and (not is_state(resident_sensor, [''false'',
        ''off'',''true'', ''on''])) ) }}'
      then:
      - service: system_log.write
        data:
          level: '{{ check_config_debuglevel }}'
          message: 'Cover Control Automation (CCA): Config issue: resident_sensor
            is only allowed to be on/off/true/false - {{this.entity_id}}'
          logger: blueprints.hvorragend.cover_control_automation
    - if:
      - '{{ state_attr(blind, ''current_position'') is none }}'
      then:
      - service: system_log.write
        data:
          level: '{{ check_config_debuglevel }}'
          message: 'Cover Control Automation (CCA): Config issue: cover is missing
            attribute current_position - {{this.entity_id}}'
          logger: blueprints.hvorragend.cover_control_automation
    - if:
      - '{{ state_attr(default_sun_sensor, ''elevation'') is none }}'
      then:
      - service: system_log.write
        data:
          level: '{{ check_config_debuglevel }}'
          message: 'Cover Control Automation (CCA): Config issue: sun sensor is missing
            attribute elevation - {{this.entity_id}}'
          logger: blueprints.hvorragend.cover_control_automation
    - if:
      - '{{ state_attr(default_sun_sensor, ''azimuth'') is none }}'
      then:
      - service: system_log.write
        data:
          level: '{{ check_config_debuglevel }}'
          message: 'Cover Control Automation (CCA): Config issue: sun sensor is missing
            attribute azimuth - {{this.entity_id}}'
          logger: blueprints.hvorragend.cover_control_automation
    - if:
      - or:
        - '{{ is_brightness_enabled and default_brightness_sensor == [] }}'
        - '{{ is_brightness_enabled and not is_number(states(default_brightness_sensor))
          }}'
      then:
      - service: system_log.write
        data:
          level: '{{ check_config_debuglevel }}'
          message: 'Cover Control Automation (CCA): Config issue: brightness sensor
            not defined or state is not numeric - {{this.entity_id}}'
          logger: blueprints.hvorragend.cover_control_automation
    - if:
      - '{{ ''cover_helper_enabled'' in cover_status_options }}'
      - '{{ state_attr(cover_status_helper, ''max'') < 254 }}'
      then:
      - service: system_log.write
        data:
          level: '{{ check_config_debuglevel }}'
          message: 'Cover Control Automation (CCA): Config issue: Wrong length of
            the cover status helper - {{this.entity_id}}'
          logger: blueprints.hvorragend.cover_control_automation
  - stop: Stopping the automation - Reset
